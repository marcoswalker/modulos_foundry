function getFonts() {
	const editor = game.settings.get("polyglot", "exportFonts");
	return {
		ArCiela: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/ArCiela.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Aztec: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Aztec.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Barazhad: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Barazhad.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Celestial: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Celestial.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Daedra: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Daedra.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		DarkEldar: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/DarkEldar.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Davek: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Davek.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Dethek: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Dethek.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		DragonAlphabet: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/dragon_alphabet.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		ElderFuthark: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/ElderFutharkFS.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Eltharin: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Eltharin.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Espruar: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Espruar.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Floki: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Floki.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		FingerAlphabet: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/FingerAlphabet.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		HighDrowic: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/HighDrowic.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		HighschoolRunes: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/HighschoolRunes.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Infernal: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Infernal.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Iokharic: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Iokharic.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		JungleSlang: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/JungleSlang.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Kargi: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Kargi.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		KremlinPremier: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/KremlinPremier.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		MageScript: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/MageScript.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		MarasEye: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/MarasEye.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		MeroiticDemotic: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/MeroiticDemotic.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		MiroslavNormal: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/MiroslavNormal.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		MusiQwik: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/MusiQwik.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		NyStormning: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/NyStormning.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		OldeEnglish: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/OldeEnglish.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		OldeEspruar: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/OldeEspruar.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		OldeThorass: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/OldeThorass.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Ophidian: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Ophidian.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Pulsian: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Pulsian.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Oriental: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Oriental.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		OrkGlyphs: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/OrkGlyphs.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Qijomi: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Qijomi.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Reanaarian: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Reanaarian.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Rellanic: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Rellanic.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Saurian: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Saurian.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		ScrapbookChinese: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/ScrapbookChinese.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Semphari: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Semphari.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Skaven: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Skaven.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Tengwar: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Tengwar.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Thassilonian: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Thassilonian.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Thorass: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Thorass.otf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Tuzluca: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Tuzluca.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
		Valmaric: {
			editor,
			fonts: [
				{
					urls: ["modules/polyglot/fonts/Valmaric.ttf"],
					weight: 400,
					style: "normal",
				},
			],
		},
	};
}

let CUSTOM_FONT_SIZES = {
	"Ar Ciela": "200",
	Aztec: "200",
	Barazhad: "200",
	Celestial: "200",
	Daedra: "200",
	"Dark Eldar": "200",
	Davek: "150",
	Dethek: "200",
	"Dragon Alphabet": "100",
	"Elder Futhark": "350",
	Eltharin: "200",
	Espruar: "150",
	Floki: "200",
	"Finger Alphabet": "150",
	"High Drowic": "150",
	"Highschool Runes": "200",
	Infernal: "230",
	Iokharic: "170",
	"Jungle Slang": "180",
	Kargi: "150",
	"Kremlin Premier": "130",
	"Mage Script": "200",
	"Maras Eye": "200",
	"Meroitic Demotic": "200",
	"Miroslav Normal": "200",
	MusiQwik: "200",
	"Ny Stormning": "160",
	"Olde English": "150",
	"Olde Espruar": "200",
	"Olde Thorass": "200",
	Ophidian: "250",
	Pulsian: "270",
	Oriental: "130",
	"Ork Glyphs": "200",
	Qijomi: "200",
	Reanaarian: "200",
	Rellanic: "200",
	Saurian: "200",
	"Scrapbook Chinese": "100",
	Semphari: "200",
	Skaven: "200",
	Tengwar: "200",
	Thassilonian: "200",
	Thorass: "200",
	Tuzluca: "200",
	Valmaric: "200",
};

class PolyglotFontSettings extends FormApplication {
	/**
	 * Default Options for this FormApplication
	 */
	static get defaultOptions() {
		const classes = ["sheet", "polyglot", "polyglot-font-settings"];
		if (game.system.id === "wfrp4e") {
			classes.push(game.system.id);
		}
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "polyglot-font-form",
			title: "Polyglot Font Settings",
			template: "./modules/polyglot/templates/FontSettings.hbs",
			classes,
			width: 780,
			height: 680,
			closeOnSubmit: true,
			resizable: true,
		});
	}

	getData() {
		const fonts = game.settings.get("polyglot", "Alphabets");
		this.fonts = {};

		for (let key in fonts) {
			this.fonts[key] = {
				label: key,
				family: fonts[key].fontFamily,
				size: game.polyglot.CustomFontSizes[key] || "100",
				alphabeticOnly: fonts[key]?.alphabeticOnly || false,
				logographical: fonts[key]?.logographical || false,
			};
		}

		return {
			fonts: this.fonts,
		};
	}

	async activateListeners(html) {
		super.activateListeners(html);

		const changeFontSize = async (event) => {
			if (!event.target.hasFocus) return;
			let size = event.target.value;
			if (event.type !== "change") {
				size -= event.originalEvent.deltaY / 10;
			}
			if (size < 50) return;
			const parent = event.target.parentElement;
			const font = parent.previousElementSibling.textContent;
			parent.nextElementSibling.nextElementSibling.nextElementSibling.style.fontSize = `${size}%`;
			this.fonts[font].size = size;
		};
		const changeFontAlphabetic = async (event) => {
			const parent = event.target.parentElement;
			const font = parent.previousElementSibling.previousElementSibling.textContent;
			this.fonts[font].alphabeticOnly = event.target.checked;
		};
		const changeFontLogographical = async (event) => {
			const parent = event.target.parentElement;
			const font = parent.previousElementSibling.previousElementSibling.previousElementSibling.textContent;
			this.fonts[font].logographical = event.target.checked;
		};

		html.find(".alphabeticOnly").on("change", changeFontAlphabetic);
		html.find(".logographical").on("change", changeFontLogographical);

		html.find(".selectatr").on("focus", (event) => {
			event.target.hasFocus = true;
		});
		html.find(".selectatr").on("blur", (event) => {
			event.target.hasFocus = false;
		});
		html.find(".selectatr").on("change", changeFontSize);
		html.find(".selectatr").on("wheel", changeFontSize);
		html.find("button").on("click", async (event) => {
			if (event.currentTarget?.dataset?.action === "reset") {
				const defaultAlphabets = new game.polyglot.languageProvider.constructor().fonts;
				game.polyglot.languageProvider.fonts = defaultAlphabets;
				await game.settings.set("polyglot", "Alphabets", game.polyglot.languageProvider.fonts);
				const defaultCustomFontSizes = game.settings.settings.get("polyglot.CustomFontSizes").default;
				await game.settings.set("polyglot", "CustomFontSizes", defaultCustomFontSizes);
				this.close();
				SettingsConfig.reloadConfirm({ world: true });
			}
		});
	}

	async _updateObject() {
		const customFontSizes = {};
		for (const [key, font] of Object.entries(this.fonts)) {
			customFontSizes[key] = font.size;
			game.polyglot.languageProvider.fonts[key].alphabeticOnly = font.alphabeticOnly;
			game.polyglot.languageProvider.fonts[key].logographical = font.logographical;
		}
		let current = game.settings.get("polyglot", "Alphabets");
		await game.settings.set("polyglot", "Alphabets", game.polyglot.languageProvider.fonts);
		current = game.settings.get("polyglot", "CustomFontSizes");
		game.polyglot.CustomFontSizes = customFontSizes;
		await game.settings.set("polyglot", "CustomFontSizes", game.polyglot.CustomFontSizes);
		const changes = !foundry.utils.isEmpty(foundry.utils.diffObject(current, game.polyglot.languageProvider.fonts))
			|| !foundry.utils.isEmpty(foundry.utils.diffObject(current, customFontSizes));
		if (changes) SettingsConfig.reloadConfirm({ world: true });
	}
}

class PolyglotGeneralSettings extends FormApplication {
	static get defaultOptions() {
		const classes = ["sheet", "polyglot", "polyglot-general-settings"];
		if (game.system.id === "wfrp4e") {
			classes.push(game.system.id);
		}
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "polyglot-general-form",
			title: "Polyglot General Settings",
			template: "./modules/polyglot/templates/GeneralSettings.hbs",
			classes,
			tabs: [{ navSelector: ".tabs", contentSelector: ".content", initial: "font" }],
			width: 600,
			height: "auto",
			closeOnSubmit: true,
		});
	}

	_prepSetting(key, flag = false) {
		const settingData = game.settings.settings.get(`polyglot.${key}`);
		if (!flag && settingData.polyglotHide) return;

		const { button, choices, default: def, hasTextarea, hint, isColor, name, range, type } = settingData;
		let select = [];
		if (choices !== undefined) {
			const type = foundry.utils.getType(choices);
			if (type === "Object") select = Object.entries(choices).map(([key, value]) => ({ key, value }));
			else if (type === "Array") select = choices;
		}

		let settingType = type.name;
		if (button) {
			settingType = "Button";
		} else if (range) {
			settingType = "Range";
		} else if (choices) {
			settingType = "Select";
		} else if (isColor) {
			settingType = "Color";
		} else if (hasTextarea) {
			settingType = "Textarea";
		}

		return {
			id: key,
			value: flag ? (game.user.flags?.polyglot?.[key] ?? def) : game.settings.get("polyglot", key),
			name,
			hint,
			type: settingType,
			range,
			select,
		};
	}

	_prepFlag(key) {
		return this._prepSetting(key, true);
	}

	async resetToDefault(key) {
		const defaultValue = game.settings.settings.get(`polyglot.${key}`).default;
		await game.settings.set("polyglot", key, defaultValue);
	}

	getData() {
		const isGM = game.user.isGM;
		let data = {};
		if (isGM) {
			data = {
				tabs: {
					font: {
						icon: "fas fa-cogs",
						name: "POLYGLOT.Fonts",
					},
					journal: {
						icon: "fas fa-book-open",
						name: "SIDEBAR.TabJournal",
					},
					languages: {
						icon: "fas fa-globe",
						name: "POLYGLOT.Languages.title",
					},
					chat: {
						icon: "fas fa-comments",
						name: "CHAT.Chat",
					},
				},
				settings: {
					font: {
						// Font Settings
						RuneRegex: this._prepSetting("RuneRegex"),
						enableAllFonts: this._prepSetting("enableAllFonts"),
						exportFonts: this._prepSetting("exportFonts"),
					},
					journal: {
						// Journal
						IgnoreJournalFontSize: this._prepSetting("IgnoreJournalFontSize"),
						JournalHighlightColor: this._prepSetting("JournalHighlightColor"),
						JournalHighlight: this._prepSetting("JournalHighlight"),
					},
					languages: {
						// Languages
						replaceLanguages: this._prepSetting("replaceLanguages"),
						defaultLanguage: this._prepSetting("defaultLanguage"),
						customLanguages: this._prepSetting("customLanguages"),
						omniglot: this._prepSetting("omniglot"),
						comprehendLanguages: this._prepSetting("comprehendLanguages"),
						truespeech: this._prepSetting("truespeech"),
					},
					chat: {
						// Chat
						displayCheckbox: this._prepSetting("displayCheckbox"),
						"display-translated": this._prepSetting("display-translated"),
						hideTranslation: this._prepSetting("hideTranslation"),
						allowOOC: this._prepSetting("allowOOC"),
						runifyGM: this._prepSetting("runifyGM"),
					},
				},
			};
		} else {
			data = {
				tabs: {
					languages: {
						icon: "fas fa-globe",
						name: "POLYGLOT.Languages.title",
					},
				},
				settings: {
					languages: {
						defaultLanguage: this._prepFlag("defaultLanguage"),
					},
				},
			};
		}

		for (const s in data.settings) {
			// eslint-disable-next-line no-unused-vars
			data.settings[s] = Object.fromEntries(
				Object.entries(data.settings[s]).filter(([key, value]) => value !== undefined),
			);
		}

		return data;
	}

	async activateListeners(html) {
		super.activateListeners(html);
		html.find("button").on("click", async (event) => {
			const dataset = event.currentTarget?.dataset;
			if (dataset?.action === "reset") {
				let keys = [
					"defaultLanguage"
				];
				if (game.user.isGM) {
					keys = [
						"RuneRegex",
						"enableAllFonts",
						"exportFonts",
						"IgnoreJournalFontSize",
						"JournalHighlightColor",
						"JournalHighlight",
						"replaceLanguages",
						"defaultLanguage",
						"customLanguages",
						"omniglot",
						"comprehendLanguages",
						"truespeech",
						"display-translated",
						"hideTranslation",
						"allowOOC",
						"runifyGM",
					];
					await Promise.all(
						keys.map(async (key) => {
							await this.resetToDefault(key);
						}),
					);
				} else {
					await Promise.all(
						keys.map(async (key) => {
							await game.user.unsetFlag("polyglot", key);
						}),
					);
				}
				this.close();
			} else if (dataset?.key) {
				const key = dataset.key;
				game.polyglot.languageProvider.settings?.[key].button?.(event);
			}
		});
		html.find(".form-group button[name]").on("click", async (event) => {
			const name = event.currentTarget.name;
			game.polyglot.languageProvider.settings?.[name].button?.(event);
		});
	}

	async _updateObject(event, formData) {
		let requiresClientReload = false;
		let requiresWorldReload = false;
		for (let [k, v] of Object.entries(foundry.utils.flattenObject(formData))) {
			let s = game.settings.settings.get(`polyglot.${k}`);
			let current = game.user.isGM ? game.settings.get(s.namespace, s.key) : game.user.getFlag("polyglot", k);
			if (v === current) continue;
			requiresClientReload ||= s.scope === "client" && s.requiresReload;
			requiresWorldReload ||= s.scope === "world" && s.requiresReload;
			if (game.user.isGM) {
				await game.settings.set(s.namespace, s.key, v);
			} else {
				await game.user.setFlag("polyglot", k, v);
			}
		}
		if (requiresClientReload || requiresWorldReload) {
			SettingsConfig.reloadConfirm({ world: requiresWorldReload });
		}
	}
}

class PolyglotLanguageSettings extends FormApplication {
	/**
	 * Default Options for this FormApplication
	 */
	static get defaultOptions() {
		const classes = ["sheet", "polyglot", "polyglot-language-settings"];
		if (game.system.id === "wfrp4e") {
			classes.push(game.system.id);
		}
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "polyglot-language-form",
			title: "Polyglot Language Settings",
			template: "./modules/polyglot/templates/LanguageSettings.hbs",
			classes,
			width: 600,
			height: 680,
			closeOnSubmit: true,
			resizable: true,
		});
	}

	getData() {
		const data = {};
		const selectedProvider = game.polyglot.languageProvider.id;
		// Insert all speed providers into the template data
		data.providers = Object.values(game.polyglot.api.providers).map((languageProvider) => {
			const provider = {};
			provider.id = languageProvider.id;
			let dotPosition = provider.id.indexOf(".");
			if (dotPosition === -1) dotPosition = provider.id.length;
			const type = provider.id.substring(0, dotPosition);
			const id = provider.id.substring(dotPosition + 1);
			if (type === "native") {
				let title = id === game.system.id ? game.system.title : id;
				provider.selectTitle = (`${game.i18n.localize("POLYGLOT.LanguageProvider.choices.native")} ${title}`).trim();
			} else {
				const name = type === "module" ? game.modules.get(id).title : game.system.title;
				provider.selectTitle = game.i18n.format(`POLYGLOT.LanguageProvider.choices.${type}`, { name });
			}
			provider.isSelected = provider.id === selectedProvider;
			return provider;
		});

		data.providerSelection = {
			id: "languageProvider",
			name: game.i18n.localize("POLYGLOT.LanguageProvider.name"),
			hint: game.i18n.localize("POLYGLOT.LanguageProvider.hint"),
			type: String,
			choices: data.providers.reduce((choices, provider) => {
				choices[provider.id] = provider.selectTitle;
				return choices;
			}, {}),
			value: selectedProvider,
			isCheckbox: false,
			isSelect: true,
			isRange: false,
		};

		this.languageProvider = data.providerSelection.value;

		function prepSetting(key) {
			const { name, hint } = game.settings.settings.get(`polyglot.${key}`);
			const value = game.settings.get("polyglot", `${key}`);
			return { value, name, hint };
		}

		const asArray = Object.entries(game.settings.get("polyglot", "Languages")).sort();

		const { name, hint } = game.settings.settings.get("polyglot.Languages");
		const filtered = asArray.filter(([key]) => {
			return (
				key !== game.polyglot.omniglot
				&& key !== game.polyglot.comprehendLanguages
				&& key !== game.polyglot.truespeech
			);
		});
		const value = Object.fromEntries(filtered);

		const languages = {
			name,
			hint,
			value,
		};

		const alphabets = prepSetting("Alphabets");

		return {
			data,
			languages,
			alphabets,
			rng: {
				default: "POLYGLOT.RandomizeRunesOptions.a",
				unique: "POLYGLOT.RandomizeRunesOptions.b",
				none: "POLYGLOT.RandomizeRunesOptions.c"
			}
		};
	}

	async activateListeners(html) {
		super.activateListeners(html);
		html.find(".polyglot-languageProvider").on("change", (event) => {
			const languagesList = html.find(".polyglot-languages-list")[0];
			const languagesWarning = html.find(".polyglot-languages-warn")[0];
			const shouldDisplayLanguages = this.languageProvider === event.target.value;
			languagesList.style.display = shouldDisplayLanguages ? "block" : "none";
			languagesWarning.style.display = shouldDisplayLanguages ? "none" : "block";
		});
		html.find(".polyglot-alphabet").each(function () {
			const font = this.previousSibling.previousSibling.children[0].value; // selectatr's value
			this.style.font = game.polyglot.languageProvider.fonts[font];
		});
		html.find(".selectatr").on("change", (event) => {
			const font = event.target.value;
			const parentElement = event.target.parentElement;
			const nextSibling = parentElement.nextSibling;
			if (nextSibling && nextSibling.nextSibling) {
				const elementToChange = nextSibling.nextSibling;
				const alphabet = game.polyglot.languageProvider.fonts[font];
				elementToChange.style.font = alphabet;
			}
		});
		html.find("button").on("click", async (event) => {
			if (event.currentTarget?.dataset?.action === "reset") {
				const current = game.settings.get("polyglot", "Languages");
				await game.settings.set("polyglot", "Languages", {});
				const defaultProvider = new game.polyglot.languageProvider.constructor();
				defaultProvider.getLanguages();
				const diff = foundry.utils.diffObject(defaultProvider.languages, current);
				await game.settings.set("polyglot", "Languages", defaultProvider.languages);
				if (Object.keys(diff).length) SettingsConfig.reloadConfirm({ world: true });
				this.close();
			}
		});
	}

	/**
	 * Executes on form submission
	 * @param {Event} ev - the form submission event
	 * @param {Object} formData - the form data
	 */
	async _updateObject(ev, formData) {
		const languageProvider = game.settings.get("polyglot", "languageProvider");
		if (languageProvider !== formData.languageProvider) {
			await game.settings.set("polyglot", "languageProvider", formData.languageProvider);
			game.polyglot.api.updateProvider();
			await game.settings.set("polyglot", "Alphabets", game.polyglot.languageProvider.fonts);
			await game.settings.set("polyglot", "Languages", game.polyglot.languageProvider.languages);
		} else {
			const languages = foundry.utils.expandObject(formData).languages;
			const current = game.settings.get("polyglot", "Languages");
			const diff = foundry.utils.diffObject(current, languages);
			if (!Object.keys(diff).length) return;
			game.polyglot.languageProvider.languages = languages;
			await game.settings.set("polyglot", "Languages", languages);
		}
		SettingsConfig.reloadConfirm({ world: true });
	}
}

/**
 * Shorthand for game.settings.register.
 * Default data: {scope: "world", config: true}
 * @function addSetting
 * @param {string} key
 * @param {object} data
 */
function addSetting(key, data) {
	const commonData = {
		name: `POLYGLOT.${key}.title`,
		hint: `POLYGLOT.${key}.hint`,
		scope: "world",
		config: true,
	};
	game.settings.register("polyglot", key, Object.assign(commonData, data));
}

function addMenuSetting(key, data) {
	const commonData = {
		name: `POLYGLOT.${key}.title`,
		hint: `POLYGLOT.${key}.hint`,
		scope: "world",
		config: false,
	};
	game.settings.register("polyglot", key, Object.assign(commonData, data));
}

function registerSettings() {
	// General Settings Menu
	game.settings.registerMenu("polyglot", "GeneralSettings", {
		name: "POLYGLOT.GeneralSettings",
		label: "POLYGLOT.GeneralSettings",
		icon: "fas fa-cogs",
		type: PolyglotGeneralSettings,
	});
	// Font Settings Menu
	game.settings.registerMenu("polyglot", "FontSettings", {
		name: "POLYGLOT.FontSettings",
		label: "POLYGLOT.FontSettings",
		icon: "fas fa-font",
		type: PolyglotFontSettings,
		restricted: true,
	});
	// Language Settings Menu
	game.settings.registerMenu("polyglot", "LanguageSettings", {
		name: "POLYGLOT.LanguageSettings",
		label: "POLYGLOT.LanguageSettings",
		icon: "fas fa-globe",
		type: PolyglotLanguageSettings,
		restricted: true,
	});
	addMenuSetting("Alphabets", {
		default: {},
		type: Object,
	});
	addMenuSetting("Languages", {
		default: {},
		type: Object,
	});

	// Font Settings
	addMenuSetting("RuneRegex", {
		default: false,
		type: Boolean,
	});
	addMenuSetting("enableAllFonts", {
		name: "POLYGLOT.enableAllFonts.title",
		hint: "POLYGLOT.enableAllFonts.hint",
		default: false,
		type: Boolean,
		requiresReload: true,
	});
	addMenuSetting("exportFonts", {
		name: "POLYGLOT.ExportFonts.title",
		hint: "POLYGLOT.ExportFonts.hint",
		default: false,
		type: Boolean,
		requiresReload: true,
	});

	// Journal Settings
	addMenuSetting("IgnoreJournalFontSize", {
		default: false,
		type: Boolean,
	});
	addMenuSetting("JournalHighlightColor", {
		default: "#ffb400",
		type: String,
		isColor: true,
		onChange: (value) => {
			document.documentElement.style.setProperty("--polyglot-journal-color", value);
		},
	});
	const hex = hexToRgb(game.settings.get("polyglot", "JournalHighlightColor"));
	document.documentElement.style.setProperty("--polyglot-journal-color", Object.values(hex).toString());
	addMenuSetting("JournalHighlight", {
		default: 25,
		range: {
			min: 0,
			max: 100,
			step: 1,
		},
		type: Number,
		onChange: (value) => {
			document.documentElement.style.setProperty("--polyglot-journal-opacity", value / 100);
		},
	});
	document.documentElement.style.setProperty(
		"--polyglot-journal-opacity",
		game.settings.get("polyglot", "JournalHighlight") / 100,
	);

	// Language Settings
	addMenuSetting("replaceLanguages", {
		name: "POLYGLOT.ReplaceLanguages.title",
		hint: "POLYGLOT.ReplaceLanguages.hint",
		default: false,
		type: Boolean,
		requiresReload: true,
		onChange: async () => {
			await game.polyglot.languageProvider.getLanguages();
			game.polyglot.languageProvider.loadLanguages();
			game.polyglot.languageProvider.reloadLanguages();
		},
	});
	addMenuSetting("defaultLanguage", {
		name: "POLYGLOT.DefaultLanguage.title",
		hint: "POLYGLOT.DefaultLanguage.hint",
		default: "",
		type: String,
		onChange: () => {
			game.polyglot.languageProvider.getDefaultLanguage();
		},
	});
	addMenuSetting("customLanguages", {
		name: "POLYGLOT.CustomLanguages.title",
		hint: "POLYGLOT.CustomLanguages.hint",
		default: "",
		type: String,
		hasTextarea: true,
		requiresReload: true,
		onChange: () => {
			game.polyglot.languageProvider.loadLanguages();
			game.polyglot.languageProvider.reloadLanguages();
		},
	});
	addMenuSetting("omniglot", {
		name: "POLYGLOT.Omniglot.title",
		hint: "POLYGLOT.Omniglot.hint",
		default: "",
		type: String,
		onChange: (value) => (game.polyglot.omniglot = value.trim().replace(/'/g, "_")),
	});
	addMenuSetting("comprehendLanguages", {
		name: "POLYGLOT.ComprehendLanguages.title",
		hint: "POLYGLOT.ComprehendLanguages.hint",
		default: "",
		type: String,
		onChange: (value) => (game.polyglot.comprehendLanguages = value.trim().replace(/'/g, "_")),
	});
	addMenuSetting("truespeech", {
		name: "POLYGLOT.Truespeech.title",
		hint: "POLYGLOT.Truespeech.hint",
		default: "",
		type: String,
		onChange: (value) => (game.polyglot.truespeech = value.trim().replace(/'/g, "_")),
	});

	// Chat Settings
	addMenuSetting("displayCheckbox", {
		name: "POLYGLOT.DisplayCheckbox.title",
		hint: "POLYGLOT.DisplayCheckbox.hint",
		default: true,
		type: Boolean,
		requiresReload: true,
	});
	addMenuSetting("display-translated", {
		name: "POLYGLOT.DisplayTranslated.title",
		hint: "POLYGLOT.DisplayTranslated.hint",
		default: true,
		type: Boolean,
	});
	addMenuSetting("hideTranslation", {
		name: "POLYGLOT.HideTranslation.title",
		hint: "POLYGLOT.HideTranslation.hint",
		default: false,
		type: Boolean,
		requiresReload: true,
	});
	// allowOOC
	addMenuSetting("runifyGM", {
		name: "POLYGLOT.ScrambleGM.title",
		hint: "POLYGLOT.ScrambleGM.hint",
		default: false,
		type: Boolean,
		requiresReload: true,
	});

	// Used Internally
	addMenuSetting("CustomFontSizes", {
		default: CUSTOM_FONT_SIZES,
		type: Object,
	});
	addMenuSetting("checkbox", {
		default: true,
		type: Boolean,
		scope: "client"
	});

	Hooks.on("i18nInit", () => {
		addMenuSetting("allowOOC", {
			name: "POLYGLOT.AllowOOC.title",
			hint: "POLYGLOT.AllowOOC.hint",
			choices: {
				a: game.i18n.localize("POLYGLOT.AllowOOCOptions.a"),
				b: game.i18n.localize("POLYGLOT.AllowOOCOptions.b"),
				c: game.i18n.localize("POLYGLOT.AllowOOCOptions.c"),
				d: game.i18n.localize("POLYGLOT.AllowOOCOptions.d"),
			},
			default: "b",
			type: String,
		});
	});
}

// Language Provider Settings
function registerProviderSettings() {
	const systemSpecificSettings = game.polyglot.languageProvider.settings;
	if (Object.keys(systemSpecificSettings).length) {
		for (let [key, data] of Object.entries(systemSpecificSettings)) {
			addSetting(key, data);
		}
	}
}

async function renderPolyglotGeneralSettingsHandler(settingsConfig, html) {
	const JournalHighlightColor = game.settings.get("polyglot", "JournalHighlightColor");

	const JournalHighlight = game.settings.get("polyglot", "JournalHighlight");
	const JournalHighlightInput = html.find('input[name="JournalHighlight"]');
	const JournalHighlightNotes = JournalHighlightInput.parent().children()[3];
	if (JournalHighlightNotes) JournalHighlightNotes.classList.add("polyglot-journal-temp");
	const hex = hexToRgb(JournalHighlightColor);
	document.documentElement.style.setProperty("--polyglot-journal-color-temp", Object.values(hex).toString());
	document.documentElement.style.setProperty("--polyglot-journal-opacity-temp", JournalHighlight / 100);

	JournalHighlightInput.on("change", (event) => {
		document.documentElement.style.setProperty("--polyglot-journal-opacity-temp", event.target.value / 100);
	});

	const JournalHighlightColorPicker = html.find('input[data-edit="JournalHighlightColor"]');
	JournalHighlightColorPicker.on("change", (event) => {
		const hex = hexToRgb(event.target.value);
		document.documentElement.style.setProperty("--polyglot-journal-color-temp", Object.values(hex).toString());
	});
}

async function renderSettingsConfigHandler(settingsConfig, html) {
	if (game.settings.settings.has("polyglot.languageDataPath")) {
		const languageDataPath = game.settings.get("polyglot", "languageDataPath");
		const languageDataPathInput = html.find('input[name="polyglot.languageDataPath"]');
		const LanguageRegexInput = html.find('input[name="polyglot.LanguageRegex"]');
		const literacyDataPathInput = html.find('input[name="polyglot.literacyDataPath"]');
		if (languageDataPath) disableCheckbox(LanguageRegexInput, true);
		else disableCheckbox(literacyDataPathInput, true);
		languageDataPathInput.on("change", (event) => {
			disableCheckbox(LanguageRegexInput, event.target.value.length);
			disableCheckbox(literacyDataPathInput, !event.target.value.length);
		});
	}
}

function disableCheckbox(checkbox, boolean) {
	checkbox.prop("disabled", boolean);
}

function getNestedData(data, path) {
	if (!RegExp(/^([\w_-]+\.)*([\w_-]+)$/).test(path)) {
		return null;
	}
	const paths = path.split(".");
	if (!paths.length) {
		return null;
	}
	let res = data;
	for (let i = 0; i < paths.length; i += 1) {
		if (res === undefined) {
			return null;
		}
		res = res?.[paths[i]];
	}
	return res;
}

function hexToRgb(hex) {
	let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result
		? {
			r: parseInt(result[1], 16),
			g: parseInt(result[2], 16),
			b: parseInt(result[3], 16),
		}
		: null;
}

/**
 * Base class for all language providers.
 * If you want to offer a language provider in your system/module you must derive this class.
 */
class LanguageProvider {
	/**
	 * @param {String} id
	 */
	constructor(id) {
		this.id = id;
	}

	/** The provider's default font key. */
	defaultFont = "Thorass";

	/**
	 * Polyglot's fonts.
	 * @var {String} fontSize - the font's size in %
	 * @var {String} fontFamily - the font's name as they are set in the CSS (generally space-less)
	 * @var {Boolean} alphabeticOnly - Optional. If a font type is meant to only replace alphabetic characters. This meant for font types that don't have all characters set.
	 * @var {Boolean} logographical - Optional. If a font is meant to use the logographical logic (e.g. Aztec, Chinese and Oriental fonts).
	 * @var {Object} replace - NOT IMPLEMENTED. Optional. A {string : replacement} pair.
	 */
	fonts = {
		"Ar Ciela": {
			fontSize: "200",
			fontFamily: "ArCiela",
			alphabeticOnly: true,
		},
		Aztec: {
			fontSize: "200",
			fontFamily: "Aztec",
			logographical: true,
		},
		Barazhad: {
			fontSize: "200",
			fontFamily: "Barazhad",
		},
		Celestial: {
			fontSize: "200",
			fontFamily: "Celestial",
		},
		Daedra: {
			fontSize: "200",
			fontFamily: "Daedra",
		},
		"Dark Eldar": {
			fontSize: "200",
			fontFamily: "DarkEldar",
			logographical: true,
		},
		Davek: {
			fontSize: "150",
			fontFamily: "Davek",
		},
		Dethek: {
			fontSize: "200",
			fontFamily: "Dethek",
		},
		"Dragon Alphabet": {
			fontSize: "170",
			fontFamily: "DragonAlphabet",
		},
		"Elder Futhark": {
			fontSize: "350",
			fontFamily: "ElderFuthark",
		},
		Eltharin: {
			fontSize: "200",
			fontFamily: "Eltharin",
			logographical: true,
		},
		Espruar: {
			fontSize: "150",
			fontFamily: "Espruar",
		},
		"Finger Alphabet": {
			fontSize: "150",
			fontFamily: "FingerAlphabet",
			alphabeticOnly: true,
			logographical: true,
		},
		Floki: {
			fontSize: "200",
			fontFamily: "Floki",
		},
		"High Drowic": {
			fontSize: "150",
			fontFamily: "HighDrowic",
		},
		"Highschool Runes": {
			fontSize: "200",
			fontFamily: "HighschoolRunes",
		},
		Infernal: {
			fontSize: "230",
			fontFamily: "Infernal",
		},
		Iokharic: {
			fontSize: "170",
			fontFamily: "Iokharic",
		},
		"Jungle Slang": {
			fontSize: "180",
			fontFamily: "JungleSlang",
			logographical: true,
		},
		Kargi: {
			fontSize: "150",
			fontFamily: "Kargi",
		},
		"Kremlin Premier": {
			fontSize: "130",
			fontFamily: "KremlinPremier",
			alphabeticOnly: true,
		},
		"Mage Script": {
			fontSize: "200",
			fontFamily: "MageScript",
			alphabeticOnly: true,
			logographical: true,
		},
		"Maras Eye": {
			fontSize: "200",
			fontFamily: "MarasEye",
		},
		"Meroitic Demotic": {
			fontSize: "200",
			fontFamily: "MeroiticDemotic",
			alphabeticOnly: true,
		},
		"Miroslav Normal": {
			fontSize: "200",
			fontFamily: "MiroslavNormal",
		},
		MusiQwik: {
			fontSize: "200",
			fontFamily: "MusiQwik",
		},
		"Ny Stormning": {
			fontSize: "160",
			fontFamily: "NyStormning",
		},
		"Olde English": {
			fontSize: "150",
			fontFamily: "OldeEnglish",
			alphabeticOnly: true,
		},
		"Olde Espruar": {
			fontSize: "200",
			fontFamily: "OldeEspruar",
		},
		"Olde Thorass": {
			fontSize: "200",
			fontFamily: "OldeThorass",
		},
		Ophidian: {
			fontSize: "250",
			fontFamily: "Ophidian",
		},
		Oriental: {
			fontSize: "130",
			fontFamily: "Oriental",
			logographical: true,
		},
		"Ork Glyphs": {
			fontSize: "200",
			fontFamily: "OrkGlyphs",
		},
		Pulsian: {
			fontSize: "270",
			fontFamily: "Pulsian",
			alphabeticOnly: true,
		},
		Qijomi: {
			fontSize: "200",
			fontFamily: "Qijomi",
		},
		Reanaarian: {
			fontSize: "200",
			fontFamily: "Reanaarian",
		},
		Rellanic: {
			fontSize: "200",
			fontFamily: "Rellanic",
		},
		Saurian: {
			fontSize: "200",
			fontFamily: "Saurian",
			logographical: true,
		},
		"Scrapbook Chinese": {
			fontSize: "130",
			fontFamily: "ScrapbookChinese",
			logographical: true,
		},
		Semphari: {
			fontSize: "200",
			fontFamily: "Semphari",
			alphabeticOnly: true,
		},
		Skaven: {
			fontSize: "200",
			fontFamily: "Skaven",
			logographical: true,
		},
		Tengwar: {
			fontSize: "200",
			fontFamily: "Tengwar",
		},
		Thassilonian: {
			fontSize: "200",
			fontFamily: "Thassilonian",
			logographical: true,
		},
		Thorass: {
			fontSize: "200",
			fontFamily: "Thorass",
		},
		Tuzluca: {
			fontSize: "200",
			fontFamily: "Tuzluca",
			alphabeticOnly: true,
		},
		Valmaric: {
			fontSize: "200",
			fontFamily: "Valmaric",
		},
	};

	/**
	 * The system's original languages.
	 * @var {String} label - The language's displayed name.
	 * @var {String} font - The key of a font set in this.fonts.
	 * @var {String} rng - Determines which type of RNG is used to generate a phrase. Base Polyglot supports these; "Default", "Unique" and "None".
	 */
	languages = {
		/*
		languageKey: {
			label: languageName, // Optional if set on this.getLanguages
			font: fontName,
			rng: "default", // Optional. Added automatically during this.getLanguages
			//See https://github.com/mclemente/fvtt-module-polyglot/issues/283
		},
		*/
	};

	/** This is needed if the LanguageProvider gets languages from compendiums, since they require the game state to be ready. */
	requiresReady = false;

	/** Legacy Support for old alphabets */
	get alphabets() {
		const alphabets = {};
		for (const language of Object.keys(this.languages)) {
			const font = this.fonts[this.languages[language].font];
			alphabets[language] = `${font.fontSize}% ${font.fontFamily}`;
		}
		return alphabets;
	}

	/** Provider settings to be added by the module. */
	get settings() {
		return {};
	}

	get replaceLanguages() {
		return game.settings.get("polyglot", "replaceLanguages");
	}

	// /////////
	// Hooks //
	// /////////

	init() {}

	i18nInit() {}

	/**
	 * Loads everything that can't be loaded on the constructor due to async/await.
	 * It Hooks on ready if the system depends on reading compendiums.
	 */
	async setup() {
		game.polyglot.omniglot = game.settings.get("polyglot", "omniglot");
		game.polyglot.comprehendLanguages = game.settings.get("polyglot", "comprehendLanguages");
		game.polyglot.truespeech = game.settings.get("polyglot", "truespeech");

		const setupSteps = async () => {
			await this.getLanguages();
			this.loadFonts();
			this.loadLanguages();
			this.loadCustomFonts();
			this.reloadLanguages();
			this.getDefaultLanguage();
		};
		if (this.requiresReady) {
			if (game.modules.get("babele")?.active) {
				Hooks.on("babele.ready", async () => {
					await setupSteps();
					Hooks.callAll("polyglot.languageProvider.ready");
				});
			} else {
				Hooks.on("ready", async () => {
					await setupSteps();
					Hooks.callAll("polyglot.languageProvider.ready");
				});
			}
		} else {
			await setupSteps();
		}
	}

	ready() {}

	/**
	 * Even though the base method doesn't have an await, some providers might need it to look into compendiums.
	 */
	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		if (CONFIG[game.system.id.toUpperCase()]?.languages) {
			if (CONFIG[game.system.id.toUpperCase()].languages.constructor === Object) {
				if (this.replaceLanguages) {
					CONFIG[game.system.id.toUpperCase()].languages = {};
				}
				const systemLanguages = CONFIG[game.system.id.toUpperCase()].languages;
				Object.keys(systemLanguages).forEach((key) => {
					const label = typeof systemLanguages[key] === "string" ? game.i18n.localize(systemLanguages[key]) : null;
					if (label) {
						langs[key] = {
							label,
							font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
							rng: languagesSetting[key]?.rng ?? "default",
						};
					}
				});
				this.languages = langs;
			}
			if (CONFIG[game.system.id.toUpperCase()].languages.constructor === Array) {
				if (this.replaceLanguages) {
					CONFIG[game.system.id.toUpperCase()].languages = [];
				}
				for (let key of CONFIG[game.system.id.toUpperCase()].languages) {
					const label = game.i18n.localize(key);
					if (!label) continue;
					langs[key.toLowerCase()] = {
						label,
						font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
						rng: languagesSetting[key]?.rng ?? "default",
					};
				}
				this.languages = langs;
			}
		} else if (Object.keys(this.languages).length) {
			if (this.replaceLanguages) {
				this.languages = {};
			} else {
				Object.keys(this.languages).forEach((key) => {
					const label = this.languages[key].label;
					if (label) {
						langs[key] = {
							label,
							font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
							rng: languagesSetting[key]?.rng ?? "default",
						};
					}
				});
				this.languages = langs;
			}
		}
	}

	/**
	 * Sets the fonts that will be available to choose on the settings.
	 */
	loadFonts() {
		this.fonts = new LanguageProvider().fonts;
		const enableAllFonts = game.settings.get("polyglot", "enableAllFonts");
		const fonts = game.settings.get("polyglot", "Alphabets");

		if (enableAllFonts) {
			for (let font in game.settings.get("core", "fonts")) {
				if (fonts[font]) {
					this.fonts[font] = fonts[font];
				} else {
					const fontSize = game.polyglot.CustomFontSizes[font] ?? "100";
					this.addFont(font, fontSize);
				}
			}
		}
		for (let font in this.fonts) {
			if (game.polyglot.CustomFontSizes[font]) {
				this.fonts[font].fontSize = game.polyglot.CustomFontSizes[font];
			}
			if (fonts[font]) {
				if (typeof fonts[font] === "string") delete this.fonts[font];
				else {
					this.fonts[font].alphabeticOnly = fonts[font]?.alphabeticOnly ?? false;
					this.fonts[font].logographical = fonts[font]?.logographical ?? false;
				}
			}
		}
	}

	/**
	 * Add languages from the settings to this.languages.
	 */
	loadLanguages() {
		const customLanguages = game.settings.get("polyglot", "customLanguages");
		const omniglot = game.settings.get("polyglot", "omniglot");
		const comprehendLanguages = game.settings.get("polyglot", "comprehendLanguages");
		const truespeech = game.settings.get("polyglot", "truespeech");
		if (this.replaceLanguages) this.languages = {};
		if (customLanguages) {
			for (let lang of customLanguages.split(/[,;]/)) {
				lang = lang.trim();
				this.addLanguage(lang);
			}
		}
		if (omniglot && !customLanguages.includes(omniglot)) this.addLanguage(omniglot);
		if (comprehendLanguages && !customLanguages.includes(comprehendLanguages)) {
			this.addLanguage(comprehendLanguages);
		}
		if (truespeech && !customLanguages.includes(truespeech)) this.addLanguage(truespeech);
	}

	/**
	 * Replace languages's fonts with the Languages setting's fonts.
	 */
	loadCustomFonts() {
		const langSettings = game.settings.get("polyglot", "Languages");
		if (JSON.stringify(langSettings) !== JSON.stringify(this.languages)) return;
		for (let lang in langSettings) {
			if (lang in this.languages && JSON.stringify(this.languages[lang]) !== JSON.stringify(langSettings[lang])) {
				this.languages[lang] = langSettings[lang];
			}
		}
	}

	/**
	 * Called when Custom Languages setting is changed.
	 */
	reloadLanguages() {
		const langSettings = foundry.utils.deepClone(game.settings.get("polyglot", "Languages"));
		if (JSON.stringify(langSettings) !== JSON.stringify(this.languages) || !Object.keys(langSettings).length) {
			return;
		}
		for (const key of Object.keys(langSettings)) {
			if (!(key in this.languages)) {
				delete this.languages[key];
				this.removeFromConfig(key);
			}
		}
		for (const key of Object.keys(this.languages)) {
			if (!(key in langSettings)) {
				langSettings[key] = this.languages[key];
			}
		}
		this.languages = langSettings;
	}

	// /////////////////
	// Font Handling //
	// /////////////////

	/**
	 * Adds a font to the Provider.
	 * @param {String} lang
	 * @param {Object} options
	 * @see loadFonts
	 */
	addFont(fontFamily, fontSize = 100, options = {}) {
		const defaultOptions = {
			alphabeticOnly: false,
			logographical: false,
			// replace: {},
		};
		this.fonts[fontFamily] = { ...defaultOptions, ...options, fontSize, fontFamily };
	}

	/**
	 * Removes a font from the Provider.
	 * @param {String} lang
	 */
	removeFont(font) {
		const key = font;
		delete this.fonts[key];
	}

	// /////////////////////
	// Language Handling //
	// /////////////////////

	/**
	 * Adds a language to the Provider.
	 * @param {String} lang
	 * @param {Object} options
	 * @see loadLanguages
	 */
	addLanguage(lang, options = {}) {
		if (!lang) return;

		const key = lang.toLowerCase().replace(/[\s']/g, "_");
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const defaultOptions = {
			font: languagesSetting[key]?.font ?? this.defaultFont,
			rng: languagesSetting[key]?.rng ?? "default",
		};

		const language = { ...defaultOptions, ...options, label: lang};

		this.languages[key] = language;
		this.addToConfig(key, lang);
	}

	/**
	 * Removes a language from the Provider if it isn't set a Custom Language.
	 * Generally called when Comprehend Languages or Tongues setting are changed.
	 * @param {String} lang
	 */
	removeLanguage(lang) {
		if (!lang) return;
		const customLanguages = game.settings.get("polyglot", "customLanguages");
		if (customLanguages.includes(lang)) return;
		const key = lang.trim().toLowerCase().replace(/[\s']/g, "_");
		delete this.languages[key];
		this.removeFromConfig(key);
	}

	/**
	 * Returns the system's default language if it exists.
	 * @returns {String}
	 */
	getSystemDefaultLanguage() {
		const keys = Object.keys(this.languages);
		if (keys.includes("common")) return "common";
		return this.languages[0] || keys[0] || "";
	}

	/**
	 * Returns defaultLang if it exists and is either a key or value on this.languages.
	 * Otherwise, returns the system's default language.
	 */
	getDefaultLanguage() {
		const getLanguage = (language) => {
			if (this.languages[language]) {
				this.defaultLanguage = language;
			} else {
				Object.entries(this.languages).every(([key, lang]) => {
					if (language === lang.label) {
						this.defaultLanguage = key;
						return false;
					}
					return true;
				});
			}
		};
		const worldDefault = game.settings.get("polyglot", "defaultLanguage");
		const userDefault = game.user.getFlag("polyglot", "defaultLanguage");
		// We have to check for World's setting first because users might input an invalid language
		if (worldDefault) {
			getLanguage(worldDefault);
		}
		if (userDefault) {
			getLanguage(userDefault);
		}
		if (this.defaultLanguage === undefined) {
			this.defaultLanguage = this.getSystemDefaultLanguage();
		}
	}

	getLanguageFont(lang) {
		return this.languages[lang]?.font ?? this.defaultFont;
	}

	// ///////////////////
	// Config Handling //
	// ///////////////////

	/**
	 * Adds a key to the languages object.
	 * Important for systems that read it for their language selector.
	 * @param {String} key
	 * @param {String} lang
	 */
	addToConfig(key, lang) {
		if (CONFIG[game.system.id.toUpperCase()]?.languages) {
			if (Array.isArray(CONFIG[game.system.id.toUpperCase()].languages)) {
				CONFIG[game.system.id.toUpperCase()].languages.push(lang);
			} else CONFIG[game.system.id.toUpperCase()].languages[key] = lang;
		}
	}

	/**
	 * Removes a key from the languages object.
	 * @param {String} key
	 */
	removeFromConfig(key) {
		if (CONFIG[game.system.id.toUpperCase()]?.languages) delete CONFIG[game.system.id.toUpperCase()].languages[key];
	}

	// //////////////////
	// User Languages //
	// //////////////////

	/**
	 * Gets an actor's languages.
	 * @param {Document} actor
	 * @var literateLanguages	For systems that support literacy (e.g. reading journals).
	 * @returns [Set, Set]
	 */
	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (actor.system?.traits?.languages) {
			for (let lang of actor.system.traits.languages.value) {
				knownLanguages.add(lang);
			}
			if (actor.system.traits.languages.custom) {
				for (let lang of actor.system.traits.languages.custom.split(/[,;]/)) {
					const key = lang.trim().toLowerCase();
					knownLanguages.add(key);
				}
			}
		} else if (actor.system?.languages?.value) {
			for (let lang of actor.system.languages.value) knownLanguages.add(lang);
			if (actor.system.languages.custom) {
				for (let lang of actor.system.languages.custom.split(/[,;]/)) {
					const key = lang.trim().toLowerCase();
					knownLanguages.add(key);
				}
			}
		} else if (this.languageDataPath?.length) {
			let data = getNestedData(actor, this.languageDataPath);
			for (let lang of data.split(/[,;]/)) {
				knownLanguages.add(lang.trim().toLowerCase());
			}
			if (this.literacyDataPath.length) {
				let data = getNestedData(actor, this.literacyDataPath);
				for (let lang of data.split(/[,;]/)) {
					literateLanguages.add(lang.trim().toLowerCase());
				}
			}
		} else if (game.settings.settings.has("polyglot.LanguageRegex")) {
			const languageRegex = game.settings.get("polyglot", "LanguageRegex");
			let myRegex = new RegExp(`${languageRegex}\\s*\\((.+)\\)`, "i");
			for (let item of actor.items) {
				const name = item?.flags?.babele?.originalName || item.name;
				// adding only the descriptive language name, not "Language (XYZ)"
				if (myRegex.test(name)) {
					knownLanguages.add(name.match(myRegex)[1].trim().toLowerCase());
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}

	/**
	 * Filters users for Polyglot.updateUserLanguages()
	 * @param {Array} ownedActors
	 * @returns
	 */
	// eslint-disable-next-line no-unused-vars
	filterUsers(ownedActors) {
		return game.users.players.filter((u) => u.hasRole(CONST.USER_ROLES.PLAYER));
	}

	/**
	 * Returns the set with the languages to be shown on the journal.
	 * Useful for systems where speaking and reading are separate skills.
	 * @param {string} lang
	 * @returns {Boolean}
	 * @see demonlordLanguageProvider.conditions
	 * @see dsa5LanguageProvider.conditions
	 */
	conditions(lang) {
		return game.polyglot.knownLanguages.has(lang);
	}
}

class GenericLanguageProvider extends LanguageProvider {
	get settings() {
		return {
			languageDataPath: {
				hint: game.i18n.format("POLYGLOT.languageDataPath.hint", {
					setting: game.i18n.localize("POLYGLOT.LanguageRegex.title"),
				}),
				default: "",
				type: String,
				requiresReload: true,
			},
			literacyDataPath: {
				hint: game.i18n.format("POLYGLOT.literacyDataPath.hint", {
					setting: game.i18n.localize("POLYGLOT.languageDataPath.title"),
				}),
				default: "",
				type: String,
				requiresReload: true,
			},
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			},
		};
	}

	async setup() {
		this.languageDataPath = game.settings.get("polyglot", "languageDataPath");
		this.literacyDataPath = game.settings.get("polyglot", "literacyDataPath");
		if (this.languageDataPath.startsWith("actor.")) this.languageDataPath = this.languageDataPath.slice(6);
		if (this.literacyDataPath.startsWith("actor.")) this.literacyDataPath = this.literacyDataPath.slice(6);
		super.setup();
	}
}

class a5eLanguageProvider extends LanguageProvider {
	languages = {
		aarakocra: {
			font: "Olde Thorass",
		},
		abyssal: {
			font: "Infernal",
		},
		aquan: {
			font: "Dethek",
		},
		auran: {
			font: "Dethek",
		},
		celestial: {
			font: "Celestial",
		},
		common: {
			font: "Thorass",
		},
		deep: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		druidic: {
			font: "Jungle Slang",
		},
		dwarvish: {
			font: "Dethek",
		},
		elvish: {
			font: "Espruar",
		},
		giant: {
			font: "Dethek",
		},
		gith: {
			font: "Pulsian",
		},
		gnoll: {
			font: "Kargi",
		},
		gnomish: {
			font: "Dethek",
		},
		goblin: {
			font: "Dethek",
		},
		halfling: {
			font: "Thorass",
		},
		ignan: {
			font: "Dethek",
		},
		infernal: {
			font: "Infernal",
		},
		orc: {
			font: "Dethek",
		},
		primordial: {
			font: "Dethek",
		},
		sylvan: {
			font: "Olde Espruar",
		},
		terran: {
			font: "Dethek",
		},
		cant: {
			font: "Thorass",
		},
		undercommon: {
			font: "High Drowic",
		},
	};

	/**
	 * Get an actor's languages
	 * @param {Document} actor
	 * @returns [Set, Set]
	 */
	getUserLanguages(actor) {
		const knownLanguages = new Set();
		const literateLanguages = new Set();

		const langs = actor.system.proficiencies?.languages;
		if (!langs) return [knownLanguages, literateLanguages];

		langs.forEach((lang) => {
			if (this.languages[lang]) knownLanguages.add(lang);
		});

		return [knownLanguages, literateLanguages];
	}
}

class ariaLanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		kohestien: {
			font: "Tuzluca",
		},
		aqab: {
			font: "Ar Ciela",
		},
		staum: {
			font: "Floki",
		},
		osmanlien: {
			font: "Eltharin",
		},
		mon: {
			font: "Valmaric",
		},
		nok: {
			font: "Dark Eldar",
		},
		carredass: {
			font: "Celestial",
		},
		blanc: {
			font: "Ork Glyphs",
		},
		knigien: {
			font: "Tengwar",
		},
		esperan: {
			font: "Thassilonian",
		},
		altabiancais: {
			font: "Espruar",
		},
		altanegrais: {
			font: "Espruar",
		},
	};

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		knownLanguages.add(game.i18n.localize("ARIA.languages.Common"));
		for (let lang of actor.items) {
			if (lang.system.language) knownLanguages.add(lang.name.toLowerCase());
		}
		return [knownLanguages, literateLanguages];
	}
}

class arsLanguageProvider extends LanguageProvider {
	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			}
		};
	}

	async getLanguages() {
		this.languages = {};
		if (this.replaceLanguages) return;
		if (game.modules.get("osric-compendium")?.active) {
			const langs = {};
			const osricPack = game.packs.get("osric-compendium.items");
			const osricItemList = await osricPack.getIndex();
			const languagesSetting = game.settings.get("polyglot", "Languages");
			let myRegex = new RegExp(`(?:Language:|${game.settings.get("polyglot", "LanguageRegex")}:)\\s*(.+)`, "i");
			for (let item of osricItemList) {
				if (myRegex.test(item.name)) {
					let label = item.name.match(myRegex)[1].trim();
					let key = label.toLowerCase();
					if (!label) continue;
					langs[key] = {
						label,
						font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
						rng: languagesSetting[key]?.rng ?? "default",
					};
				}
			}
			this.languages = langs;
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		let myRegex = new RegExp(`(?:Language:|${game.settings.get("polyglot", "LanguageRegex")}:)\\s*(.+)`, "i");
		for (let item of actor.items) {
			// adding only the descriptive language name, not "Language: XYZ"
			if (myRegex.test(item.name)) knownLanguages.add(item.name.match(myRegex)[1].trim().toLowerCase());
		}
		return [knownLanguages, literateLanguages];
	}
}

class coc7LanguageProvider extends LanguageProvider {
	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			},
		};
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let item of actor.items) {
			const match = item.name.match(`${game.settings.get("polyglot", "LanguageRegex")}\\s*\\((.+)\\)`, "i")
				|| item.name.match(`${game.i18n.localize("POLYGLOT.COC7.LanguageOwn")}\\s*\\((.+)\\)`, "i")
				|| item.name.match(`${game.i18n.localize("POLYGLOT.COC7.LanguageAny")}\\s*\\((.+)\\)`, "i")
				|| item.name.match(`${game.i18n.localize("POLYGLOT.COC7.LanguageOther")}\\s*\\((.+)\\)`, "i");
			// adding only the descriptive language name, not "Language (XYZ)"
			if (match) knownLanguages.add(match[1].trim().toLowerCase());
			else {
				switch (item.system.specialization) {
					case "LanguageSpec":
					case "Language":
					case "Language (Own)":
					case "Language (Other)":
					case game.i18n.localize("POLYGLOT.COC7.LanguageOwn"):
					case game.i18n.localize("POLYGLOT.COC7.LanguageAny"):
					case game.i18n.localize("POLYGLOT.COC7.LanguageOther"):
					case game.i18n.localize("CoC7.language"):
						knownLanguages.add(item.name.trim().toLowerCase());
						break;
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}
}

class cyberpunkRedLanguageProvider extends LanguageProvider {
	defaultFont = "Olde English";

	languages = {
		streetslang: {
			font: "Olde English",
		},
		arabic: {
			font: "Ar Ciela",
		},
		bengali: {
			font: "Olde English",
		},
		berber: {
			font: "Olde English",
		},
		burmese: {
			font: "Ar Ciela",
		},
		cantonese: {
			font: "Oriental",
		},
		chinese: {
			font: "Oriental",
		},
		cree: {
			font: "Olde English",
		},
		creole: {
			font: "Olde English",
		},
		dari: {
			font: "Olde English",
		},
		dutch: {
			font: "Olde English",
		},
		english: {
			font: "Olde English",
		},
		farsi: {
			font: "Ar Ciela",
		},
		filipino: {
			font: "Ar Ciela",
		},
		finnish: {
			font: "Kremlin Premier",
		},
		french: {
			font: "Olde English",
		},
		german: {
			font: "Miroslav Normal",
		},
		guarani: {
			font: "Olde English",
		},
		hausa: {
			font: "Olde English",
		},
		hawaiian: {
			font: "Olde English",
		},
		hebrew: {
			font: "Olde English",
		},
		hindi: {
			font: "Ar Ciela",
		},
		indonesian: {
			font: "Ar Ciela",
		},
		italian: {
			font: "Olde English",
		},
		japanese: {
			font: "Oriental",
		},
		khmer: {
			font: "Ar Ciela",
		},
		korean: {
			font: "Oriental",
		},
		lingala: {
			font: "Olde English",
		},
		malayan: {
			font: "Ar Ciela",
		},
		mandarin: {
			font: "Oriental",
		},
		maori: {
			font: "Olde English",
		},
		mayan: {
			font: "Olde English",
		},
		mongolian: {
			font: "Ar Ciela",
		},
		navajo: {
			font: "Olde English",
		},
		nepali: {
			font: "Ar Ciela",
		},
		norwegian: {
			font: "Miroslav Normal",
		},
		oromo: {
			font: "Olde English",
		},
		pamanyungan: {
			font: "Olde English",
		},
		polish: {
			font: "Kremlin Premier",
		},
		portuguese: {
			font: "Olde English",
		},
		quechua: {
			font: "Olde English",
		},
		romanian: {
			font: "Kremlin Premier",
		},
		russian: {
			font: "Kremlin Premier",
		},
		sinhalese: {
			font: "Olde English",
		},
		spanish: {
			font: "Olde English",
		},
		swahili: {
			font: "Olde English",
		},
		tahitian: {
			font: "Olde English",
		},
		tamil: {
			font: "Olde English",
		},
		turkish: {
			font: "Ar Ciela",
		},
		twi: {
			font: "Olde English",
		},
		ukrainian: {
			font: "Kremlin Premier",
		},
		urdu: {
			font: "Ar Ciela",
		},
		vietnamese: {
			font: "Ar Ciela",
		},
		yoruba: {
			font: "Olde English",
		},
	};

	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			},
		};
	}

	async getLanguages() {
		const originalLanguages = {
			streetslang: "Streetslang",
			arabic: "Arabic",
			bengali: "Bengali",
			berber: "Berber",
			burmese: "Burmese",
			cantonese: "Cantonese",
			chinese: "Scrapbook Chinese",
			cree: "Cree",
			creole: "Creole",
			dari: "Dari",
			dutch: "Dutch",
			english: "English",
			farsi: "Farsi",
			filipino: "Filipino",
			finnish: "Finnish",
			french: "French",
			german: "German",
			guarani: "Guarani",
			hausa: "Hausa",
			hawaiian: "Hawaiian",
			hebrew: "Hebrew",
			hindi: "Hindi",
			indonesian: "Indonesian",
			italian: "Italian",
			japanese: "Japanese",
			khmer: "Khmer",
			korean: "Korean",
			lingala: "Lingala",
			malayan: "Malayan",
			mandarin: "Mandarin",
			maori: "Maori",
			mayan: "Mayan",
			mongolian: "Mongolian",
			navajo: "Navajo",
			nepali: "Nepali",
			norwegian: "Norwegian",
			oromo: "Oromo",
			pamanyungan: "Pama-nyungan",
			polish: "Polish",
			portuguese: "Portuguese",
			quechua: "Quechua",
			romanian: "Romanian",
			russian: "Russian",
			sinhalese: "Sinhalese",
			spanish: "Spanish",
			swahili: "Swahili",
			tahitian: "Tahitian",
			tamil: "Tamil",
			turkish: "Turkish",
			twi: "Twi",
			ukrainian: "Ukrainian",
			urdu: "Urdu",
			vietnamese: "Vietnamese",
			yoruba: "Yoruba",
		};
		const langs = {};
		const languagesSetting = game.settings.get("polyglot", "Languages");
		for (let lang in originalLanguages) {
			const label = originalLanguages[lang];
			if (!label) continue;
			langs[lang] = {
				label,
				font: languagesSetting[lang]?.font || this.languages[lang]?.font || this.defaultFont,
				rng: languagesSetting[lang]?.rng ?? "default",
			};
		}
		this.languages = this.replaceLanguages ? {} : langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		const languageRegex = game.settings.get("polyglot", "LanguageRegex");
		let myRegex = new RegExp(`${languageRegex}\\s*\\((.+)\\)`, "i");
		for (let item of actor.items) {
			if (item.type === "skill") {
				if (myRegex.test(item.name)) {
					knownLanguages.add(item.name.match(myRegex)[1].trim().toLowerCase());
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}
}

class d35eLanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		aarakocra: {
			font: "Olde Thorass",
		},
		abyssal: {
			font: "Infernal",
		},
		aquan: {
			font: "Dethek",
		},
		auran: {
			font: "Dethek",
		},
		celestial: {
			font: "Celestial",
		},
		deep: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		druidic: {
			font: "Jungle Slang",
		},
		dwarven: {
			font: "Dethek",
		},
		elven: {
			font: "Espruar",
		},
		giant: {
			font: "Dethek",
		},
		gith: {
			font: "tirsu",
		},
		gnoll: {
			font: "Kargi",
		},
		gnome: {
			font: "Dethek",
		},
		goblin: {
			font: "Dethek",
		},
		halfling: {
			font: "Thorass",
		},
		ignan: {
			font: "Dethek",
		},
		infernal: {
			font: "Infernal",
		},
		orc: {
			font: "Dethek",
		},
		primordial: {
			font: "Dethek",
		},
		sylvan: {
			font: "Olde Espruar",
		},
		terran: {
			font: "Dethek",
		},
		cant: {
			font: "Thorass",
		},
		treant: {
			font: "Olde Espruar",
		},
		undercommon: {
			font: "High Drowic",
		},
	};
}

class darkHeresyLanguageProvider extends LanguageProvider {
	languages = {
		lowGothic: {
			font: "Infernal",
		},
		chapterRunes: {
			font: "",
		},
		chaosMarks: {
			font: "",
		},
		eldar: {
			font: "",
		},
		highGothic: {
			font: "Infernal",
		},
		imperialCodes: {
			font: "",
		},
		mercenary: {
			font: "",
		},
		necrontyr: {
			font: "",
		},
		ork: {
			font: "Ork Glyphs",
		},
		technaLingua: {
			font: "",
		},
		tau: {
			font: "",
		},
		underworld: {
			font: "",
		},
		xenosMarkings: {
			font: "",
		},
	};

	getSystemDefaultLanguage() {
		return "lowGothic";
	}

	async getLanguages() {
		if (this.replaceLanguages) {
			this.languages = {};
		} else {
			const originalLanguages = {
				chapterRunes: "Chapter Runes",
				chaosMarks: "Chaos Marks",
				eldar: "Eldar",
				highGothic: "High Gothic",
				imperialCodes: "Imperial Codes",
				lowGothic: "Low Gothic",
				mercenary: "Mercenary",
				necrontyr: "Necrontyr",
				ork: "Ork",
				tau: "Tau",
				technaLingua: "Techna-Lingua",
				underworld: "Underworld",
				xenosMarkings: "Xenos Markings",
			};
			const langs = {};
			const languagesSetting = game.settings.get("polyglot", "Languages");
			for (let lang in originalLanguages) {
				langs[lang] = {
					label: originalLanguages[lang],
					font: languagesSetting[lang]?.font || this.languages[lang]?.font || this.defaultFont,
					rng: languagesSetting[lang]?.rng ?? "default",
				};
			}
			this.languages = langs;
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang in actor.system.skills.linguistics.specialities) {
			if (actor.system.skills.linguistics.specialities[lang].advance >= 0) knownLanguages.add(lang);
		}
		return [knownLanguages, literateLanguages];
	}
}

class dccLanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		draconic: {
			font: "Iokharic",
		},
		dwarvish: {
			font: "Dethek",
		},
		elvish: {
			font: "Espruar",
		},
		giant: {
			font: "Dethek",
		},
		gnoll: {
			font: "Kargi",
		},
		goblin: {
			font: "Dethek",
		},
		halfling: {
			font: "Thorass",
		},
		orc: {
			font: "Dethek",
		},
		cant: {
			font: "Thorass",
		},
	};

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang of actor.system.details.languages.split(/[,;]/)) knownLanguages.add(lang.trim().toLowerCase());
		return [knownLanguages, literateLanguages];
	}
}

class demonlordLanguageProvider extends LanguageProvider {
	languages = {
		"Common Tongue": {
			font: "Thorass",
		},
		"Dark Speech": {
			font: "Infernal",
		},
		"High Archaic": {
			font: "Mage Script",
		},
		Elvish: {
			font: "Espruar",
		},
		Dwarfish: {
			font: "Dethek",
		},
		"Dead Languages": {
			font: "Olde Thorass",
		},
		"Secret Language": {
			font: "Thassilonian",
		},
		Trollish: {
			font: "Ar Ciela",
		},
		Centauri: {
			font: "High Drowic",
		},
		Gnomish: {
			font: "High Drowic",
		},
		Amrin: {
			font: "Thorass",
		},
		Balgrennish: {
			font: "Tengwar",
		},
		Bhali: {
			font: "Tengwar",
		},
		Edene: {
			font: "Thorass",
		},
		Erath: {
			font: "Thorass",
		},
		Grennish: {
			font: "Tengwar",
		},
		Kalasan: {
			font: "Thorass",
		},
		Woad: {
			font: "Jungle Slang",
		},
		Sylphen: {
			font: "High Drowic",
		},
		Molekin: {
			font: "Barazhad",
		},
		Naga: {
			font: "Barazhad",
		},
		Yerath: {
			font: "Barazhad",
		},
	};

	requiresReady = true;

	getSystemDefaultLanguage() {
		return "Common Tongue";
	}

	async getLanguages() {
		if (this.replaceLanguages) {
			this.languages = {};
			return;
		}
		const demonlordPack = game.packs.get("demonlord.languages");
		const demonlordItemList = await demonlordPack.getIndex();
		const languagesSetting = game.settings.get("polyglot", "Languages");
		for (let item of demonlordItemList) {
			const originalName = item?.flags?.babele?.originalName || item.name;
			this.languages[originalName] = {
				label: item.name,
				font: languagesSetting[originalName]?.font || this.languages[originalName]?.font || this.defaultFont,
				rng: languagesSetting[originalName]?.rng ?? "default",
			};
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let item of actor.items) {
			if (item.type === "language") {
				const name = item?.flags?.babele?.originalName || item.name;
				if (item.system.speak) knownLanguages.add(name);
				if (item.system.read) literateLanguages.add(name);
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class dnd4eLanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		abyssal: {
			font: "Barazhad",
		},
		deep: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		dwarven: {
			font: "Davek",
		},
		elven: {
			font: "Rellanic",
		},
		giant: {
			font: "Davek",
		},
		goblin: {
			font: "Davek",
		},
		primordial: {
			font: "Davek",
		},
		supernal: {
			font: "Celestial",
		},
	};

	addToConfig(key, lang) {
		CONFIG.DND4E.spoken[key] = lang;
	}

	removeFromConfig(key) {
		delete CONFIG.DND4E.spoken[key];
	}

	async getLanguages() {
		const langs = {};
		if (this.replaceLanguages) {
			CONFIG.DND4E.spoken = {};
		}
		const languagesSetting = game.settings.get("polyglot", "Languages");
		for (let lang in CONFIG.DND4E.spoken) {
			langs[lang] = {
				label: CONFIG.DND4E.spoken[lang],
				font: languagesSetting[lang]?.font || this.languages[lang]?.font || this.defaultFont,
				rng: languagesSetting[lang]?.rng ?? "default",
			};
		}
		this.languages = langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang of actor.system.languages.spoken.value) {
			knownLanguages.add(lang);
		}
		// for (let lang of actor.system.languages.script.value) {
		// 	literateLanguages.add(lang);
		// }
		return [knownLanguages, literateLanguages];
	}
}

class dnd5eLanguageProvider extends LanguageProvider {
	languages = {
		aarakocra: {
			font: "Olde Thorass",
		},
		abyssal: {
			font: "Infernal",
		},
		aquan: {
			font: "Dethek",
		},
		auran: {
			font: "Dethek",
		},
		celestial: {
			font: "Celestial",
		},
		common: {
			font: "Thorass",
		},
		deep: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		druidic: {
			font: "Jungle Slang",
		},
		dwarvish: {
			font: "Dethek",
		},
		elvish: {
			font: "Espruar",
		},
		giant: {
			font: "Dethek",
		},
		gith: {
			font: "Pulsian",
		},
		gnoll: {
			font: "Kargi",
		},
		gnomish: {
			font: "Dethek",
		},
		goblin: {
			font: "Dethek",
		},
		halfling: {
			font: "Thorass",
		},
		ignan: {
			font: "Dethek",
		},
		infernal: {
			font: "Infernal",
		},
		orc: {
			font: "Dethek",
		},
		primordial: {
			font: "Dethek",
		},
		sylvan: {
			font: "Olde Espruar",
		},
		terran: {
			font: "Dethek",
		},
		cant: {
			font: "Thorass",
		},
		undercommon: {
			font: "High Drowic",
		},
	};

	get settings() {
		return {
			"DND5E.SpecialLanguages": {
				type: String,
				default: game.i18n.localize("DND5E.LanguagesCommon"),
			}
		};
	}

	languageRarities = ["standard", "exotic"];

	multiLanguages = {
		primordial: {
			parent: "exotic"
		}
	};

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		if (this.replaceLanguages) {
			CONFIG.DND5E.languages = {};
			this.languageRarities = [];
			this.multiLanguages = {};
		}
		const systemLanguages = CONFIG.DND5E.languages;
		const getLang = (key, target) => {
			const processLanguage = (label) => {
				if (label) {
					langs[key] = {
						label,
						font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
						rng: languagesSetting[key]?.rng ?? "default",
					};
				}
			};

			if (key in this.multiLanguages) {
				processLanguage(game.i18n.localize(target[key].label));
			}
			if (target[key].children) {
				Object.keys(target[key].children).forEach((kkey) => {
					getLang(kkey, target[key].children);
				});
			} else {
				processLanguage(game.i18n.localize(target[key]));
			}
		};
		Object.keys(systemLanguages).forEach((key) => {
			if (this.languageRarities.includes(key)) {
				Object.keys(systemLanguages[key].children).forEach((kkey) => {
					getLang(kkey, systemLanguages[key].children);
				});
			} else {
				getLang(key, systemLanguages);
			}
		});
		this.languages = langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (actor.system?.traits?.languages) {
			for (let lang of actor.system.traits.languages.value) {
				if (this.languageRarities.includes(lang)) {
					for (let l in CONFIG.DND5E.languages[lang].children) {
						knownLanguages.add(l.trim().replace(/[\s']/g, "_"));
					}
				} else {
					knownLanguages.add(lang.trim().replace(/[\s']/g, "_"));
				}
				if (lang in this.multiLanguages) {
					const parent = this.multiLanguages[lang].parent;
					let languages;
					if (parent) {
						const parentChildren = CONFIG.DND5E.languages[parent].children;
						languages = parentChildren[lang].children;
					} else {
						languages = CONFIG.DND5E.languages[lang].children;
					}
					for (let l in languages) {
						knownLanguages.add(l.trim().replace(/[\s']/g, "_"));
					}
				}
			}
			if (actor.system.traits.languages.custom) {
				const defaultSpecialLanguage = game.settings
					.get("polyglot", "DND5E.SpecialLanguages")
					.trim()
					.toLowerCase();
				// eslint-disable-next-line no-unsafe-optional-chaining
				for (let lang of actor.system.traits.languages?.custom.split(/[;]/)) {
					let key = lang.trim().toLowerCase();
					try {
						if (/(usually common)|(in life)|(its creator)|(?<=any)(.*)(?=language)/i.test(key)) {
							knownLanguages.add(defaultSpecialLanguage);
						} else if (/(?<=usually)(.*)(?=\))/g.test(key)) {
							key = key.match(/(?<=usually)(.*)(?=\))/g)[0].trim();
							knownLanguages.add(key);
						} else if (/(?<=understands)(.*)(?=but can't speak it)/g.test(key)) {
							key = key.match(/(?<=understands)(.*)(?=but can't speak it)/g)[0].trim();
							knownLanguages.add(key);
						} else if (/(.*)(?=plus)/.test(key)) {
							key = key.match(/(.*)(?=plus)/)[0].trim();
							knownLanguages.add(key);
						} else {
							knownLanguages.add(key);
						}
					} catch(err) {
						console.error(
							`Polyglot | Failed to get custom language "${key}" from actor "${actor.name}".`,
							err
						);
					}
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}

	filterUsers(ownedActors) {
		const filtered = super.filterUsers(ownedActors);
		const party = game.settings.get("dnd5e", "primaryParty")?.actor;
		if (party?.system?.members.length) {
			const members = Array.from(party.system.members.ids);
			const users = filtered.filter((u) => ownedActors.some((actor) => members.includes(actor.id) && actor.testUserPermission(u, "OWNER")));
			return users;
		}
		return filtered;
	}
}

class dsa5LanguageProvider extends LanguageProvider {
	defaultFont = "Ophidian";

	languages = {
		garethi: {
			label: "Garethi",
			font: "Miroslav Normal",
			rng: "default",
		},
		alaani: {
			label: "Alaani",
			font: "Miroslav Normal",
			rng: "default",
		},
		"altes alaani": {
			label: "Altes Alaani",
			font: "Highschool Runes",
			rng: "default",
		},
		amulashtra: {
			label: "Amulashtra",
			font: "Qijomi",
			rng: "default",
		},
		angram: {
			label: "Angram",
			font: "Skaven",
			rng: "default",
		},
		"angram-bilderschrift": {
			label: "Angram-Bilderschrift",
			font: "Skaven",
			rng: "default",
		},
		arkanil: {
			label: "Arkanil",
			font: "Ar Ciela",
			rng: "default",
		},
		asdharia: {
			label: "Asdharia",
			font: "Tengwar",
			rng: "default",
		},
		atak: {
			label: "Atak",
			font: "FingerAlphabet",
			rng: "default",
		},
		aureliani: {
			label: "Aureliani",
			font: "Infernal",
			rng: "default",
		},
		bosparano: {
			label: "Bosparano",
			font: "Miroslav Normal",
			rng: "default",
		},
		chrmk: {
			label: "Chrmk",
			font: "Iokharic",
			rng: "default",
		},
		chuchas: {
			label: "Chuchas",
			font: "Kargi",
			rng: "default",
		},
		"drakhard-zinken": {
			label: "Drakhard-Zinken",
			font: "Celestial",
			rng: "default",
		},
		fjarningsch: {
			label: "Fjarningsch",
			font: "Dethek",
			rng: "default",
		},
		"geheiligte glyphen von unau": {
			label: "Geheiligte Glyphen von Unau",
			font: "High Drowic",
			rng: "default",
		},
		"gimaril-glyphen": {
			label: "Gimaril-Glyphen",
			font: "Semphari",
			rng: "default",
		},
		goblinisch: {
			label: "Goblinisch",
			font: "Ork Glyphs",
			rng: "default",
		},
		"hjaldingsche hunen": {
			font: "Olde Thorass",
			rng: "default",
		},
		"imperiale zeichen": {
			label: "Imperiale Zeichen",
			font: "Infernal",
			rng: "default",
		},
		isdira: {
			label: "Isdira",
			font: "Tengwar",
			rng: "default",
		},
		"isdira- und asdharia-zeichen": {
			label: "Isdira- und Asdharia-Zeichen",
			font: "Tengwar",
			rng: "default",
		},
		"kusliker zeichen": {
			label: "Kusliker Zeichen",
			font: "Miroslav Normal",
			rng: "default",
		},
		mohisch: {
			label: "Mohisch",
			font: "Jungle Slang",
			rng: "default",
		},
		"nanduria-zeichen": {
			label: "Nanduria-Zeichen",
			font: "Espruar",
			rng: "default",
		},
		nujuka: {
			label: "Nujuka",
			font: "Reanaarian",
			rng: "default",
		},
		ogrisch: {
			label: "Ogrisch",
			font: "Ork Glyphs",
			rng: "default",
		},
		oloarkh: {
			label: "Oloarkh",
			font: "Ork Glyphs",
			rng: "default",
		},
		ologhaijan: {
			label: "Ologhaijan",
			font: "Ork Glyphs",
			rng: "default",
		},
		protozelemja: {
			label: "Protozelemja",
			font: "Kargi",
			rng: "default",
		},
		rabensprache: {
			label: "Rabensprache",
			font: "Valmaric",
			rng: "default",
		},
		rogolan: {
			label: "Rogolan",
			font: "Elder Futhark",
			rng: "default",
		},
		"rogolan-runen": {
			label: "Rogolan-Runen",
			font: "Elder Futhark",
			rng: "default",
		},
		rssahh: {
			label: "Rssahh",
			font: "Iokharic",
			rng: "default",
		},
		ruuz: {
			label: "Ruuz",
			font: "Valmaric",
			rng: "default",
		},
		"saga-thorwalsch": {
			label: "Saga-Thorwalsch",
			font: "Olde Thorass",
			rng: "default",
		},
		tahaya: {
			label: "Tahaya",
			font: "Jungle Slang",
			rng: "default",
		},
		thorwalsch: {
			label: "Thorwalsch",
			font: "Floki",
			rng: "default",
		},
		"thorwalsche runen": {
			label: "Thorwalsche Runen",
			font: "Floki",
			rng: "default",
		},
		trollisch: {
			label: "Trollisch",
			font: "Eltharin",
			rng: "default",
		},
		"trollische raumbildschrift": {
			label: "Trollische Raumbildschrift",
			font: "Eltharin",
			rng: "default",
		},
		tulamidya: {
			label: "Tulamidya",
			font: "Valmaric",
			rng: "default",
		},
		"tulamidya-zeichen": {
			label: "Tulamidya-Zeichen",
			font: "Valmaric",
			rng: "default",
		},
		"ur-tulamidya": {
			label: "Ur-Tulamidya",
			font: "Olde Espruar",
			rng: "default",
		},
		"ur-tulamidya-zeichen": {
			label: "Ur-Tulamidya-Zeichen",
			font: "Olde Espruar",
			rng: "default",
		},
		"yash-hualay-glyphen": {
			label: "Yash-Hualay-Glyphen",
			font: "Kargi",
			rng: "default",
		},
		zelemja: {
			label: "Zelemja",
			font: "Iokharic",
			rng: "default",
		},
		zhayad: {
			label: "Zhayad",
			font: "Pulsian",
			rng: "default",
		},
		"zhayad-zeichen": {
			label: "Zhayad-Zeichen",
			font: "Pulsian",
			rng: "default",
		},
		zyklopisch: {
			label: "Zyklopisch",
			font: "Miroslav Normal",
			rng: "default",
		},
	};

	requiresReady = true;

	getSystemDefaultLanguage() {
		return "garethi";
	}

	async getLanguages() {
		if (this.replaceLanguages) {
			this.languages = {};
			return;
		}
		if (game.modules.has("dsa5-core") && game.modules.get("dsa5-core").active) {
			// use old compendium for versions < 11, remove this if module's version doesn't support those foundry versions anymore
			const packName = Number(game.version.split(".")[0]) < 11 ? "abilities" : "equipment";
			const dsa5Pack = game.packs.get(`dsa5-core.core${packName}`) ?? game.packs.get(`dsa5-core.coreen${packName}`);
			const languages = {};
			if (dsa5Pack) {
				const dsa5ItemList = await dsa5Pack.getIndex();
				const languageRegex = new RegExp(`${game.i18n.localize("LocalizedIDs.language")}\\s*\\((.+)\\)`, "i");
				const literacyRegex = new RegExp(`${game.i18n.localize("LocalizedIDs.literacy")}\\s*\\((.+)\\)`, "i");
				const languagesSetting = game.settings.get("polyglot", "Languages");

				const setLanguageInfo = (item, regex) => {
					const match = item.name.match(regex);
					if (match) {
						const label = match[1].trim();
						const key = label.toLowerCase();
						languages[key] = {
							label,
							font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
							rng: languagesSetting[key]?.rng ?? "default",
						};
					}
				};

				for (const item of dsa5ItemList) {
					if (languageRegex.test(item.name)) setLanguageInfo(item, languageRegex);
					else if (literacyRegex.test(item.name)) setLanguageInfo(item, literacyRegex);
				}
				this.languages = languages;
			} else {
				ui.notifications.error(
					`Polyglot | The ${game.modules.get("dsa5-core").title} pack wasn't retrieved correctly. Defaulting to built-in languages.`,
					{
						console: false,
					}
				);
			}
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		let languageRegex = new RegExp(`${game.i18n.localize("LocalizedIDs.language")}\\s*\\((.+)\\)`, "i");
		let literacyRegex = new RegExp(`${game.i18n.localize("LocalizedIDs.literacy")}\\s*\\((.+)\\)`, "i");
		for (let item of actor.items) {
			if (item.system.category?.value === "language") {
				if (languageRegex.test(item.name)) {
					knownLanguages.add(item.name.match(languageRegex)[1].trim().toLowerCase());
				} else if (literacyRegex.test(item.name)) {
					literateLanguages.add(item.name.match(literacyRegex)[1].trim().toLowerCase());
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class earthdawn4eLanguageProvider extends LanguageProvider {
	languages = {
		human: {
			font: "Thorass",
		},
		dwarven: {
			font: "Dethek",
		},
		elven: {
			font: "Espruar",
		},
		windling: {
			font: "Olde Thorass",
		},
		obsidiman: {
			font: "Dethek",
		},
		troll: {
			font: "Jungle Slang",
		},
		ork: {
			font: "Dethek",
		},
		tskrang: {
			font: "Iokharic",
		},
	};

	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			},
			LiteracyRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Read"),
			},
		};
	}

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		for (let lang in this.languages) {
			this.languages[lang] = {
				label: game.i18n.localize(`earthdawn.l.language${lang.capitalize()}`),
				font: languagesSetting[lang]?.font || this.languages[lang]?.font || this.defaultFont,
				rng: languagesSetting[lang]?.rng ?? "default",
			};
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang in actor.system.speak.languages) {
			if (actor.system.speak.languages[lang]) knownLanguages.add(lang);
		}
		for (let lang in actor.system.languages.write) {
			if (actor.system.write.languages[lang]) literateLanguages.add(lang);
		}
		if (actor.system.languages.other) {
			const languageRegex = game.settings.get("polyglot", "LanguageRegex");
			const literacyRegex = game.settings.get("polyglot", "LiteracyRegex");
			for (let lang of actor.system.languages.other.split(/[,;]/)) {
				const languageMatch = lang.match(`${languageRegex} \\((.+)\\)`, "i");
				const literacyMatch = lang.match(`${literacyRegex} \\((.+)\\)`, "i");
				if (languageMatch || literacyMatch) {
					if (languageMatch) knownLanguages.add(languageMatch[1].trim().toLowerCase());
					else if (literacyMatch) literateLanguages.add(literacyMatch[1].trim().toLowerCase());
				} else {
					knownLanguages.add(lang.trim().toLowerCase());
					literateLanguages.add(lang.trim().toLowerCase());
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class fggLanguageProvider extends LanguageProvider {
	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang of actor.system.languages.value) knownLanguages.add(lang.toLowerCase());
		if (actor.system.languages.custom) {
			for (let lang of actor.system.languages.custom.split(/[,;]/)) knownLanguages.add(lang.trim().toLowerCase());
		}
		return [knownLanguages, literateLanguages];
	}
}

class gurpsLanguageProvider extends LanguageProvider {
	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.Generic.Language"),
			},
		};
	}

	/**
	 * Search through all of the advantages (including recursing into containers) looking for "Language" or translation.
	 * Depending on the source, it can be two different patterns, Language: NAME (optionals) or Language (NAME) (optionals)
	 * and the advantage names may or may not be translated, so we must search for both
	 */
	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (GURPS) {
			const languageRegex = game.settings.get("polyglot", "LanguageRegex");
			// window.GURPS set when the GURPS game system is loaded
			let npat1 = ": +(?<name>[^\\(]+)";
			let npat2 = " +\\((?<name>[^\\)]+)\\)";
			GURPS.recurselist(actor.system.ads, (advantage) => {
				if (!this.updateForPattern(
					advantage,
					new RegExp(languageRegex + npat1, "i"),
					knownLanguages,
					literateLanguages
				)) if (!this.updateForPattern(
					advantage,
					new RegExp(languageRegex + npat2, "i"),
					knownLanguages,
					literateLanguages
				)) if (!this.updateForPattern(
					advantage,
					new RegExp(game.i18n.localize("GURPS.language") + npat1, "i"),
					knownLanguages,
					literateLanguages,
					true
				)) this.updateForPattern(
					advantage,
					new RegExp(game.i18n.localize("GURPS.language") + npat2, "i"),
					knownLanguages,
					literateLanguages,
					true
				);
			});
		}
		return [knownLanguages, literateLanguages];
	}

	/**
	If we match on the Language name, search the name (or the notes)
	for indicators of spoken or written levels of comprehension in English, or translated
  */
	updateForPattern(advantage, regex, knownLanguages, literateLanguages, langDetected = false) {
		let match = advantage.name.match(regex);
		if (match) {
			const lang = match.groups.name.trim().toLowerCase();
			const wpat = new RegExp(game.i18n.localize("GURPS.written"), "i");
			const spat = new RegExp(game.i18n.localize("GURPS.spoken"), "i");
			let written = advantage.name.match(/written/i) || advantage.notes?.match(/written/i);
			if (!written) written = advantage.name.match(wpat) || advantage.notes?.match(wpat);
			let spoken = advantage.name.match(/spoken/i) || advantage.notes?.match(/spoken/i);
			if (!spoken) spoken = advantage.name.match(spat) || advantage.notes?.match(spat);
			if (written && spoken) {
				knownLanguages.add(lang);
				literateLanguages.add(lang);
				return true;
			} else if (written) {
				literateLanguages.add(lang);
				return true;
			} else if (spoken) {
				knownLanguages.add(lang);
				return true;
			} else if (langDetected) { // neither is specificaly identified, assume both if "Language" detected
				knownLanguages.add(lang);
				literateLanguages.add(lang);
				return true;
			}
		}
		return false;
	}
}

class oseLanguageProvider extends LanguageProvider {
	languages = {
		Common: {
			label: "Common",
			font: "Thorass",
			rng: "default",
		},
		Lawful: {
			label: "Lawful",
			font: "Celestial",
			rng: "default",
		},
		Chaotic: {
			label: "Chaotic",
			font: "Barazhad",
			rng: "default",
		},
		Neutral: {
			label: "Neutral",
			font: "Infernal",
			rng: "default",
		},
		Bugbear: {
			label: "Bugbear",
			font: "Dethek",
			rng: "default",
		},
		Doppelgnger: {
			label: "Doppelgnger",
			font: "Pulsian",
			rng: "default",
		},
		Dragon: {
			label: "Dragon",
			font: "Iokharic",
			rng: "default",
		},
		Dwarvish: {
			label: "Dwarvish",
			font: "Dethek",
			rng: "default",
		},
		Elvish: {
			label: "Elvish",
			font: "Espruar",
			rng: "default",
		},
		Gargoyle: {
			label: "Gargoyle",
			font: "High Drowic",
			rng: "default",
		},
		Gnoll: {
			label: "Gnoll",
			font: "Kargi",
			rng: "default",
		},
		Gnomish: {
			label: "Gnomish",
			font: "Tengwar",
			rng: "default",
		},
		Goblin: {
			label: "Goblin",
			font: "Dethek",
			rng: "default",
		},
		Halfling: {
			label: "Halfling",
			rng: "default",
		},
		Harpy: {
			label: "Harpy",
			font: "Olde Thorass",
			rng: "default",
		},
		Hobgoblin: {
			label: "Hobgoblin",
			font: "Dethek",
			rng: "default",
		},
		Kobold: {
			label: "Kobold",
			font: "Iokharic",
			rng: "default",
		},
		"Lizard Man": {
			label: "Lizard Man",
			font: "Iokharic",
			rng: "default",
		},
		Medusa: {
			label: "Medusa",
			font: "High Drowic",
			rng: "default",
		},
		Minotaur: {
			label: "Minotaur",
			font: "Olde Espruar",
			rng: "default",
		},
		Ogre: {
			label: "Ogre",
			font: "Meroitic Demotic",
			rng: "default",
		},
		Orcish: {
			label: "Orcish",
			font: "Dethek",
			rng: "default",
		},
		Pixie: {
			label: "Pixie",
			font: "Olde Espruar",
			rng: "default",
		},
	};

	async getLanguages() {
		if (this.replaceLanguages) {
			this.languages = {};
			return;
		}
		const languagesSetting = game.settings.get("polyglot", "Languages");
		CONFIG.OSE.languages.forEach((key) => {
			this.languages[key] = {
				label: key,
				font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
				rng: languagesSetting[key]?.rng ?? "default",
			};
		});
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang of actor.system.languages.value) knownLanguages.add(lang);
		return [knownLanguages, literateLanguages];
	}
}

class pf1LanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		aboleth: {
			font: "Ar Ciela",
		},
		abyssal: {
			font: "Barazhad",
		},
		aklo: {
			font: "Ophidian",
		},
		algollthu: {
			font: "Ar Ciela",
		},
		anadi: {
			font: "Jungle Slang",
		},
		aquan: {
			font: "Olde Thorass",
		},
		arboreal: {
			font: "Olde Espruar",
		},
		auran: {
			font: "Olde Thorass",
		},
		azlanti: {
			font: "Tengwar",
		},
		boggard: {
			font: "Semphari",
		},
		caligni: {
			font: "High Drowic",
		},
		celestial: {
			font: "Celestial",
		},
		cyclops: {
			font: "Meroitic Demotic",
		},
		daemonic: {
			font: "Infernal",
		},
		dark: {
			font: "High Drowic",
		},
		destrachan: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		drowsign: {
			font: "Finger Alphabet",
		},
		druidic: {
			font: "Jungle Slang",
		},
		dwarven: {
			font: "Dethek",
		},
		dziriak: {
			font: "Pulsian",
		},
		elven: {
			font: "Espruar",
		},
		erutaki: {
			font: "Tuzluca",
		},
		garundi: {
			font: "Qijomi",
		},
		giant: {
			font: "Meroitic Demotic",
		},
		gnoll: {
			font: "Kargi",
		},
		gnome: {
			font: "Dethek",
		},
		gnomish: {
			font: "Dethek",
		},
		goblin: {
			font: "Kargi",
		},
		grippli: {
			font: "Semphari",
		},
		hallit: {
			font: "Tengwar",
		},
		ignan: {
			font: "Dethek",
		},
		iruxi: {
			font: "Semphari",
		},
		jistkan: {
			font: "Valmaric",
		},
		jotun: {
			font: "Meroitic Demotic",
		},
		jyoti: {
			font: "Celestial",
		},
		infernal: {
			font: "Infernal",
		},
		kelish: {
			font: "Highschool Runes",
		},
		mwangi: {
			font: "Tengwar",
		},
		necril: {
			font: "High Drowic",
		},
		orc: {
			font: "Dethek",
		},
		orcish: {
			font: "Dethek",
		},
		polyglot: {
			font: "Tengwar",
		},
		protean: {
			font: "Barazhad",
		},
		requian: {
			font: "Reanaarian",
		},
		shoanti: {
			font: "Tengwar",
		},
		skald: {
			font: "Valmaric",
		},
		sphinx: {
			font: "Reanaarian",
		},
		strix: {
			font: "Infernal",
		},
		sylvan: {
			font: "Olde Espruar",
		},
		shoony: {
			font: "Dethek",
		},
		taldane: {
			font: "Tengwar",
		},
		tengu: {
			font: "Oriental",
		},
		terran: {
			font: "Dethek",
		},
		thassilonian: {
			font: "Thassilonian",
		},
		tien: {
			font: "Oriental",
		},
		treant: {
			font: "Olde Espruar",
		},
		undercommon: {
			font: "High Drowic",
		},
		utopian: {
			font: "Maras Eye",
		},
		varisian: {
			font: "Tengwar",
		},
		vegepygmy: {
			font: "Kargi",
		},
		vudrani: {
			font: "Qijomi",
		},
	};

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (actor.system?.traits?.languages) {
			for (let lang of actor.system.traits.languages.total) {
				knownLanguages.add(lang);
			}
			if (actor.system.traits.languages.customTotal) {
				for (let lang of actor.system.traits.languages.customTotal) {
					const key = lang.trim().toLowerCase();
					knownLanguages.add(key);
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}
}

class pf2eLanguageProvider extends LanguageProvider {
	languages = {
		chthonian: {
			font: "Barazhad",
		},
		aklo: {
			font: "Ophidian",
		},
		alghollthu: {
			font: "Ar Ciela",
		},
		anadi: {
			font: "Jungle Slang",
		},
		thalassic: {
			font: "Olde Thorass",
		},
		arboreal: {
			font: "Olde Espruar",
		},
		sussuran: {
			font: "Olde Thorass",
		},
		azlanti: {
			font: "Tengwar",
		},
		boggard: {
			font: "Semphari",
		},
		caligni: {
			font: "High Drowic",
		},
		empyrean: {
			font: "Celestial",
		},
		cyclops: {
			font: "Meroitic Demotic",
		},
		daemonic: {
			font: "Infernal",
		},
		destrachan: {
			font: "Ar Ciela",
		},
		draconic: {
			font: "Iokharic",
		},
		wildsong: {
			font: "Jungle Slang",
		},
		dwarven: {
			font: "Dethek",
		},
		dziriak: {
			font: "Pulsian",
		},
		elven: {
			font: "Espruar",
		},
		erutaki: {
			font: "Tuzluca",
		},
		garundi: {
			font: "Qijomi",
		},
		kholo: {
			font: "Kargi",
		},
		gnomish: {
			font: "Dethek",
		},
		goblin: {
			font: "Kargi",
		},
		grippli: {
			font: "Semphari",
		},
		hallit: {
			font: "Tengwar",
		},
		pyric: {
			font: "Dethek",
		},
		iruxi: {
			font: "Semphari",
		},
		jistkan: {
			font: "Valmaric",
		},
		jotun: {
			font: "Meroitic Demotic",
		},
		jyoti: {
			font: "Celestial",
		},
		diabolic: {
			font: "Infernal",
		},
		kelish: {
			font: "Highschool Runes",
		},
		mwangi: {
			font: "Tengwar",
		},
		necril: {
			font: "High Drowic",
		},
		orcish: {
			font: "Dethek",
		},
		protean: {
			font: "Barazhad",
		},
		requian: {
			font: "Reanaarian",
		},
		shoanti: {
			font: "Tengwar",
		},
		skald: {
			font: "Valmaric",
		},
		sphinx: {
			font: "Reanaarian",
		},
		strix: {
			font: "Infernal",
		},
		sylvan: {
			font: "Olde Espruar",
		},
		shoony: {
			font: "Dethek",
		},
		taldane: {
			font: "Tengwar",
		},
		tengu: {
			font: "Oriental",
		},
		petran: {
			font: "Dethek",
		},
		thassilonian: {
			font: "Thassilonian",
		},
		tien: {
			font: "Oriental",
		},
		sakvroth: {
			font: "High Drowic",
		},
		utopian: {
			font: "Maras Eye",
		},
		varisian: {
			font: "Tengwar",
		},
		vudrani: {
			font: "Qijomi",
		},
	};

	get settings() {
		return {
			replaceLanguages: {
				...game.settings.settings.get("polyglot.replaceLanguages"),
				hint: "POLYGLOT.PF2E.replaceLanguages.hint"
			},
			customLanguages: {
				polyglotHide: true,
				...game.settings.settings.get("polyglot.customLanguages"),
			},
			defaultLanguage: {
				polyglotHide: true,
				...game.settings.settings.get("polyglot.defaultLanguage"),
			},
		};
	}

	init() {
		if (this.replaceLanguages) {
			CONFIG.PF2E.languages = {
				common: "PF2E.Actor.Creature.Language.common"
			};
		}
		Hooks.on("closeHomebrewElements", async (homebrewElements, html) => {
			await game.polyglot.languageProvider.getLanguages();
			await game.settings.set("polyglot", "Languages", game.polyglot.languageProvider.languages);
			game.polyglot.updateUserLanguages();
		});
	}

	ready() {
		if (game.user.isGM) {
			const pf2eDefaultLanguage = game.settings.get("pf2e", "homebrew.languageRarities").commonLanguage;
			const pf2eDefaultLangString = game.i18n.localize(CONFIG.PF2E.languages[pf2eDefaultLanguage]);
			const messagesInCommon = game.messages.contents
				.slice(-CONFIG.ChatMessage.batchSize)
				.filter((m) => m.flags?.polyglot?.language === "common");
			if (!messagesInCommon.length) return;

			new Dialog({
				title: "Polyglot Changes",
				content: `<div>
					<p>Polyglot has updated to integrate some new features of PF2e, you can read all changes on <a class="hyperlink" href="https://github.com/mclemente/fvtt-module-polyglot/releases/tag/2.3.24" target="_blank" rel="nofollow noopener">this link</a>.</p>
					<p style="color: red"><b>These changes will render all chat messages written in Common unreadable for players that know Common. They need to be updated to a proper language.</b></p>
					<p>Polyglot will update the language of the last ${messagesInCommon.length} Common messages to <b style="color: red">${pf2eDefaultLangString}</b>.</p>
					<p>If you want to change them to another language on PF2e, you can do so by changing PF2e's "Common" language in the Homebrew Elements menu and reloading the page.</p>
				</div>`,
				buttons: {
					site: {
						label: "Polyglot Wiki",
						icon: '<i class="fas fa-landmark"></i>',
						callback: () => window.open("https://github.com/mclemente/fvtt-module-polyglot/wiki/%5BPF2e%5D-Languages")
					},
					update: {
						label: `Update to ${pf2eDefaultLangString}`,
						icon: '<i class="fa-solid fa-wrench"></i>',
						callback: () => {
							const changed = messagesInCommon.map((m) => {
								return {
									_id: m._id,
									"flags.polyglot.language": pf2eDefaultLanguage
								};
							});
							ChatMessage.updateDocuments(changed);
						}
					}
				}
			}, { width: 500 }).render(true);
		}
	}

	async getLanguages() {
		const customSystemLanguages = game.settings.get("pf2e", "homebrew.languages");
		if (this.replaceLanguages) {
			CONFIG.PF2E.languages = {
				common: "PF2E.Actor.Creature.Language.common"
			};
		}
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		const systemLanguages = foundry.utils.deepClone(CONFIG.PF2E.languages);
		delete systemLanguages.common;
		Object.entries(systemLanguages).forEach(([key, value]) => {
			langs[key] = {
				label: game.i18n.has(value) ? game.i18n.localize(value) : value,
				font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
				rng: languagesSetting[key]?.rng ?? "default",
			};
		});
		customSystemLanguages.filter((lang) => !(lang.id in systemLanguages)).forEach((l) => {
			const key = l.id;
			langs[key] = {
				label: l.value,
				font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
				rng: languagesSetting[key]?.rng ?? "default",
			};
			if (this.replaceLanguages) CONFIG.PF2E.languages[key] = l.value;
		});
		this.languages = langs;
	}

	loadLanguages() {}

	addLanguage() {}

	removeLanguage() {}

	getSystemDefaultLanguage() {
		return game.settings.get("pf2e", "homebrew.languageRarities").commonLanguage;
	}

	getDefaultLanguage() {
		const getLanguage = (language) => {
			if (this.languages[language]) {
				this.defaultLanguage = language;
			} else {
				Object.entries(this.languages).every(([key, lang]) => {
					if (language === lang.label) {
						this.defaultLanguage = key;
						return false;
					}
					return true;
				});
			}
		};
		const userDefault = game.user.getFlag("polyglot", "defaultLanguage");
		if (userDefault) {
			getLanguage(userDefault);
		}
		if (this.defaultLanguage === undefined) {
			this.defaultLanguage = this.getSystemDefaultLanguage();
		}
	}

	filterUsers(ownedActors) {
		const filtered = super.filterUsers(ownedActors);
		if (game.actors.party?.members.length) {
			const members = game.actors.party.members.map((a) => a.id);
			const users = filtered.filter((user) => ownedActors.some((actor) => members.includes(actor.id) && actor.testUserPermission(user, "OWNER")));
			return users;
		}
		return filtered;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		const languageRarities = game.settings.get("pf2e", "homebrew.languageRarities");
		const actorLanguages = actor.system?.details?.languages;
		if (actorLanguages) {
			for (let lang of actorLanguages.value) {
				if (lang === "common" && languageRarities.commonLanguage) {
					knownLanguages.add(languageRarities.commonLanguage);
				} else if (lang in CONFIG.PF2E.languages && !languageRarities.unavailable.has(lang)) {
					knownLanguages.add(lang);
				}
			}
		}
		return [knownLanguages, literateLanguages];
	}
}

class sfrpgLanguageProvider extends LanguageProvider {
	languages = {
		common: {
			font: "Thorass",
		},
		abyssal: {
			font: "Barazhad",
		},
		akito: {
			font: "Thorass",
		},
		aklo: {
			font: "Ophidian",
		},
		arkanen: {
			font: "Thorass",
		},
		aquan: {
			font: "Olde Thorass",
		},
		auran: {
			font: "Olde Thorass",
		},
		azlanti: {
			font: "Tengwar",
		},
		celestial: {
			font: "Celestial",
		},
		draconic: {
			font: "Iokharic",
		},
		drow: {
			font: "High Drowic",
		},
		dwarven: {
			font: "Dethek",
		},
		elven: {
			font: "Espruar",
		},
		gnome: {
			font: "Dethek",
		},
		goblin: {
			font: "Kargi",
		},
		halfling: {
			font: "Thorass",
		},
		ignan: {
			font: "Dethek",
		},
		infernal: {
			font: "Infernal",
		},
		kalo: {
			font: "Thorass",
		},
		kasatha: {
			font: "Thorass",
		},
		Nchaki: {
			font: "Thorass",
		},
		orc: {
			font: "Dethek",
		},
		sarcesian: {
			font: "Thorass",
		},
		shirren: {
			font: "Thorass",
		},
		shobhad: {
			font: "Thorass",
		},
		terran: {
			font: "Olde Thorass",
		},
		triaxian: {
			font: "Thorass",
		},
		vercite: {
			font: "Thorass",
		},
		vesk: {
			font: "Thorass",
		},
		ysoki: {
			font: "Thorass",
		},
	};
}

class shadowrun5eLanguageProvider extends LanguageProvider {
	defaultFont = "Olde English";

	languages = {
		cityspeak: {
			label: "Cityspeak",
			font: "Olde English",
		},
		spanish: {
			label: "Spanish",
			font: "Olde English",
		},
		lakota: {
			label: "Lakota",
			font: "Olde English",
		},
		dakota: {
			label: "Dakota",
			font: "Olde English",
		},
		navajo: {
			label: "Navajo",
			font: "Olde English",
		},
		russian: {
			label: "Russian",
			font: "Kremlin Premier",
		},
		french: {
			label: "French",
			font: "Olde English",
		},
		italian: {
			label: "Italian",
			font: "Olde English",
		},
		german: {
			label: "German",
			font: "Olde English",
		},
		aztlaner: {
			label: "Aztlaner Spanish",
			font: "Aztec",
		},
		sperethiel: {
			label: "Sperethiel",
			font: "Espruar",
		},
		orzet: {
			label: "Or'zet",
			font: "Ork Glyphs",
		},
		english: {
			label: "English",
			font: "Olde English",
		},
		japanese: {
			label: "Japanese",
			font: "Oriental",
		},
		mandarin: {
			label: "Mandarin",
			font: "Scrapbook Chinese",
		},
	};

	getSystemDefaultLanguage() {
		return "cityspeak";
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang in actor.system.skills.language.value) {
			knownLanguages.add(actor.system.skills.language.value[lang].name.toLowerCase());
		}
		return [knownLanguages, literateLanguages];
	}
}

class splittermondLanguageProvider extends LanguageProvider {
	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		const isLiterate = actor.items.filter((item) => item.name === "Literat" && item.type === "strength").length > 0;
		actor.items
			.filter((item) => item.type === "language")
			.forEach((item) => {
				const name = item.name.trim().toLowerCase();
				knownLanguages.add(name);
				if (isLiterate) literateLanguages.add(name);
			});
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class sw5eLanguageProvider extends LanguageProvider {
	languages = {
		basic: {
			font: "Celestial",
		},
		abyssin: {
			font: "Barazhad",
		},
		aleena: {
			font: "Jungle Slang",
		},
		antarian: {
			font: "Ar Ciela",
		},
		anzellan: {
			font: "Valmaric",
		},
		aqualish: {
			font: "Floki",
		},
		arconese: {
			font: "Ork Glyphs",
		},
		ardennian: {
			font: "Thorass",
		},
		arkanian: {
			font: "Celestial",
		},
		balosur: {
			font: "Ar Ciela",
		},
		barabel: {
			font: "Dark Eldar",
		},
		besalisk: {
			font: "Barazhad",
		},
		binary: {
			font: "Celestial",
		},
		bith: {
			font: "Skaven",
		},
		bocce: {
			font: "Tuzluca",
		},
		bothese: {
			font: "Infernal",
		},
		catharese: {
			font: "Espruar",
		},
		cerean: {
			font: "Olde Espruar",
		},
		"chadra-fan": {
			font: "Infernal",
		},
		chagri: {
			font: "Ophidian",
		},
		cheunh: {
			font: "Ar Ciela",
		},
		chevin: {
			font: "Eltharin",
		},
		chironan: {
			font: "Saurian",
		},
		clawdite: {
			font: "Reanaarian",
		},
		codruese: {
			font: "Meroitic Demotic",
		},
		colicoid: {
			font: "Thassilonian",
		},
		dashadi: {
			font: "Iokharic",
		},
		defel: {
			font: "Dark Eldar",
		},
		devaronese: {
			font: "Iokharic",
		},
		dosh: {
			font: "Iokharic",
		},
		draethos: {
			font: "Pulsian",
		},
		durese: {
			font: "Reanaarian",
		},
		dug: {
			font: "Qijomi",
		},
		ewokese: {
			font: "Skaven",
		},
		falleen: {
			font: "Tengwar",
		},
		felucianese: {
			font: "Skaven",
		},
		gamorrese: {
			font: "Highschool Runes",
		},
		gand: {
			font: "Reanaarian",
		},
		geonosian: {
			font: "Maras Eye",
		},
		givin: {
			font: "High Drowic",
		},
		gran: {
			font: "Qijomi",
		},
		gungan: {
			font: "Highschool Runes",
		},
		hapan: {
			font: "Valmaric",
		},
		harchese: {
			font: "Thassilonian",
		},
		herglese: {
			font: "Ophidian",
		},
		honoghran: {
			font: "Tuzluca",
		},
		huttese: {
			font: "Thassilonian",
		},
		iktotchese: {
			font: "Iokharic",
		},
		ithorese: {
			font: "Dethek",
		},
		jawaese: {
			font: "Valmaric",
		},
		kaleesh: {
			font: "Infernal",
		},
		kaminoan: {
			font: "Ar Ciela",
		},
		karkaran: {
			font: "Ophidian",
		},
		keldor: {
			font: "Meroitic Demotic",
		},
		kharan: {
			font: "Ar Ciela",
		},
		killik: {
			font: "Thassilonian",
		},
		klatooinian: {
			font: "Thassilonian",
		},
		kubazian: {
			font: "Olde Thorass",
		},
		kushiban: {
			font: "Thorass",
		},
		kyuzo: {
			font: "Barazhad",
		},
		lannik: {
			font: "Semphari",
		},
		lasat: {
			font: "Floki",
		},
		lowickese: {
			font: "Qijomi",
		},
		lurmese: {
			font: "Jungle Slang",
		},
		mandoa: {
			font: "Kargi",
		},
		miralukese: {
			font: "Miroslav Normal",
		},
		mirialan: {
			font: "Miroslav Normal",
		},
		moncal: {
			font: "Dark Eldar",
		},
		mustafarian: {
			font: "Ork Glyphs",
		},
		muun: {
			font: "Tengwar",
		},
		nautila: {
			font: "Ophidian",
		},
		ortolan: {
			font: "Thorass",
		},
		pakpak: {
			font: "Olde Thorass",
		},
		pyke: {
			font: "Meroitic Demotic",
		},
		quarrenese: {
			font: "Ophidian",
		},
		rakata: {
			font: "Iokharic",
		},
		rattataki: {
			font: "Infernal",
		},
		rishii: {
			font: "Maras Eye",
		},
		rodese: {
			font: "Meroitic Demotic",
		},
		ryn: {
			font: "Espruar",
		},
		selkatha: {
			font: "Ophidian",
		},
		semblan: {
			font: "Finger Alphabet",
		},
		shistavanen: {
			font: "Pulsian",
		},
		shyriiwook: {
			font: "Olde Espruar",
		},
		sith: {
			font: "High Drowic",
		},
		squibbian: {
			font: "Valmaric",
		},
		sriluurian: {
			font: "Jungle Slang",
		},
		"ssi-ruuvi": {
			font: "Maras Eye",
		},
		sullustese: {
			font: "Highschool Runes",
		},
		talzzi: {
			font: "Olde Thorass",
		},
		tarasinese: {
			font: "Olde Espruar",
		},
		thisspiasian: {
			font: "Ar Ciela",
		},
		togorese: {
			font: "Floki",
		},
		togruti: {
			font: "Pulsian",
		},
		toydarian: {
			font: "Espruar",
		},
		tusken: {
			font: "Semphari",
		},
		"twi'leki": {
			font: "Tuzluca",
		},
		ugnaught: {
			font: "Floki",
		},
		umbaran: {
			font: "Jungle Slang",
		},
		utapese: {
			font: "Eltharin",
		},
		verpine: {
			font: "Thassilonian",
		},
		vong: {
			font: "Valmaric",
		},
		voss: {
			font: "Iokharic",
		},
		yevethan: {
			font: "High Drowic",
		},
		zabraki: {
			font: "Maras Eye",
		},
		zygerrian: {
			font: "Floki",
		},
	};

	languageRarities = ["standard", "exotic"];

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		if (this.replaceLanguages) {
			CONFIG.SW5E.languages = {};
		}
		const systemLanguages = CONFIG.SW5E.languages;
		const getLang = (key, target) => {
			const processLanguage = (label) => {
				if (label) {
					langs[key] = {
						label,
						font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
						rng: languagesSetting[key]?.rng ?? "default",
					};
				}
			};

			if (target[key].children) {
				Object.keys(target[key].children).forEach((kkey) => {
					getLang(kkey, target[key].children);
				});
			} else {
				processLanguage(game.i18n.localize(target[key]));
			}
		};
		Object.keys(systemLanguages).forEach((key) => {
			if (this.languageRarities.includes(key)) {
				Object.keys(systemLanguages[key].children).forEach((kkey) => {
					getLang(kkey, systemLanguages[key].children);
				});
			} else {
				getLang(key, systemLanguages);
			}
		});
		this.languages = langs;
	}

	getSystemDefaultLanguage() {
		return "basic";
	}
}

class swadeLanguageProvider extends LanguageProvider {
	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.SWADE.LanguageSkills"),
			},
			"SWADE.AdditionalLanguageStat": {
				hint: game.i18n.format("POLYGLOT.SWADE.AdditionalLanguageStat.hint", {
					setting: game.i18n.localize("POLYGLOT.LanguageRegex.title"),
				}),
				type: String,
				default: "",
			},
			"SWADE.AdditionalLiterateStat": {
				hint: game.i18n.format("POLYGLOT.SWADE.AdditionalLiterateStat.hint", {
					setting: game.i18n.localize("POLYGLOT.SWADE.AdditionalLanguageStat.title"),
				}),
				type: String,
				default: "",
			},
		};
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		const additionalLanguageStat = game.settings.get("polyglot", "SWADE.AdditionalLanguageStat");
		const additionalLiterateStat = game.settings.get("polyglot", "SWADE.AdditionalLiterateStat");
		if (!additionalLanguageStat) {
			const languageRegex = game.settings.get("polyglot", "LanguageRegex");
			let myRegex = new RegExp(`${languageRegex} \\((.+)\\)`, "i");
			for (let item of actor.items) {
				const name = item?.flags?.babele?.originalName || item.name;
				if (myRegex.test(name)) knownLanguages.add(name.match(myRegex)[1].trim().toLowerCase());
			}
		} else {
			const languages = actor.system?.additionalStats?.[additionalLanguageStat]?.value.split(/[,;]/) ?? [];
			for (let lang of languages) {
				lang = lang.trim();
				knownLanguages.add(lang.toLowerCase());
				this.addLanguage(lang);
			}
		}
		if (additionalLiterateStat) {
			const languages = actor.system?.additionalStats?.[additionalLiterateStat]?.value.split(/[,;]/) ?? [];
			for (let lang of languages) {
				lang = lang.trim();
				literateLanguages.add(lang.toLowerCase());
				this.addLanguage(lang);
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		if (game.settings.get("polyglot", "SWADE.AdditionalLiterateStat")) return game.polyglot.literateLanguages.has(lang);
		return game.polyglot.knownLanguages.has(lang);
	}
}

class tormenta20LanguageProvider extends LanguageProvider {
	languages = {
		comum: {
			font: "Thorass",
		},
		abissal: {
			font: "Barazhad",
		},
		anao: {
			font: "Dethek",
		},
		aquan: {
			font: "Olde Thorass",
		},
		auran: {
			font: "Olde Thorass",
		},
		celestial: {
			font: "Celestial",
		},
		draconico: {
			font: "Iokharic",
		},
		elfico: {
			font: "Espruar",
		},
		gigante: {
			font: "Meroitic Demotic",
		},
		gnoll: {
			font: "Kargi",
		},
		goblin: {
			font: "Kargi",
		},
		ignan: {
			font: "Olde Thorass",
		},
		infernal: {
			font: "Infernal",
		},
		orc: {
			font: "Dethek",
		},
		silvestre: {
			font: "Olde Espruar",
		},
		terran: {
			font: "Olde Thorass",
		},
	};

	getSystemDefaultLanguage() {
		return "comum";
	}

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		if (this.replaceLanguages) {
			CONFIG.T20.idiomas = {};
		}
		Object.keys(CONFIG.T20.idiomas).forEach((key) => {
			const label = CONFIG.T20.idiomas[key];
			if (label) {
				langs[key] = {
					label,
					font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
					rng: languagesSetting[key]?.rng ?? "default",
				};
			}
		});
		this.languages = langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let lang of actor.system.tracos.idiomas.value) knownLanguages.add(lang);
		return [knownLanguages, literateLanguages];
	}
}

class uesrpgLanguageProvider extends LanguageProvider {
	languages = {
		cyrodilic: {
			font: "Thorass",
		},
		aldmeri: {
			font: "Espruar",
		},
		ayleidoon: {
			font: "Espruar",
		},
		bosmeri: {
			font: "Mage Script",
		},
		daedric: {
			font: "Daedra",
		},
		dovah: {
			font: "Dragon Alphabet",
		},
		dunmeri: {
			font: "High Drowic",
		},
		dwemeris: {
			font: "Dethek",
		},
		falmer: {
			font: "Ar Ciela",
		},
		jel: {
			font: "Ophidian",
		},
		nordic: {
			font: "Ny Stormning",
		},
		taagra: {
			font: "Jungle Slang",
		},
		yoku: {
			font: "Oriental",
		},
	};

	getSystemDefaultLanguage() {
		return "cyrodilic";
	}

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		const langs = {};
		if (this.replaceLanguages) {
			CONFIG.UESRPG.languages = {};
		}
		Object.keys(CONFIG.UESRPG.languages).forEach((key) => {
			const label = CONFIG.UESRPG.languages[key];
			if (label) {
				langs[key] = {
					label,
					font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
					rng: languagesSetting[key]?.rng ?? "default",
				};
			}
		});
		this.languages = langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		for (let item of actor.items) {
			if (item.type === "language") {
				if (item.system.speak) knownLanguages.add(item.name.trim().toLowerCase());
				if (item.system.readWrite) literateLanguages.add(item.name.trim().toLowerCase());
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class wfrp4eLanguageProvider extends LanguageProvider {
	languages = {
		reikspiel: {
			font: "Infernal",
		},
		wastelander: {
			font: "Infernal",
		},
		classical: {
			font: "Infernal",
		},
		cathan: {
			font: "Oriental",
		},
		tilean: {
			font: "Thorass",
		},
		estalian: {
			font: "Tengwar",
		},
		gospodarinyi: {
			font: "Miroslav Normal",
		},
		albion: {
			font: "Elder Futhark",
		},
		norse: {
			font: "Elder Futhark",
		},
		bretonnian: {
			font: "romance",
		},
		druhir: {
			font: "Dark Eldar",
		},
		elthrin: {
			font: "Eltharin",
		},
		orcish: {
			font: "Ork Glyphs",
		},
		queekish: {
			font: "Skaven",
		},
		slaan: {
			font: "Saurian",
		},
		khazalid: {
			font: "Floki",
		},
		magick: {
			font: "Eltharin",
		},
	};

	requiresReady = true;

	get settings() {
		return {
			LanguageRegex: {
				type: String,
				default: game.i18n.localize("POLYGLOT.WFRP4E.LanguageSkills"),
			},
			ReadWrite: {
				name: game.i18n.localize("POLYGLOT.WFRP4E.ReadWrite.title"),
				hint: game.i18n.localize("POLYGLOT.WFRP4E.ReadWrite.hint"),
				type: String,
				default: game.i18n.localize("POLYGLOT.WFRP4E.ReadWrite.default"),
			},
		};
	}

	getSystemDefaultLanguage() {
		return "reikspiel";
	}

	async getLanguages() {
		if (this.replaceLanguages) {
			this.languages = {};
			return;
		}
		let wfrp4ePack;
		if (isNewerVersion(game.system.version, "6.6.1")) {
			wfrp4ePack = game.packs.get("wfrp4e-core.items") || game.packs.get("wfrp4e.basic");
		} else {
			wfrp4ePack = game.packs.get("wfrp4e-core.skills") || game.packs.get("wfrp4e.basic");
		}
		const wfrp4eItemList = await wfrp4ePack.getIndex();
		const languagesSetting = game.settings.get("polyglot", "Languages");
		let myRegex = new RegExp(`(?:Language|${game.settings.get("polyglot", "LanguageRegex")})\\s*\\((.+)\\)`, "i");
		const langs = {};
		for (let item of wfrp4eItemList) {
			if (myRegex.test(item.name)) {
				let label = item.name.match(myRegex)[1].trim();
				let key = label.toLowerCase();
				if (!label) continue;
				langs[key] = {
					label,
					font: languagesSetting[key]?.font || this.languages[key]?.font || this.defaultFont,
					rng: languagesSetting[key]?.rng ?? "default",
				};
			}
		}
		this.languages = langs;
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		const readWrite = game.settings.get("polyglot", "ReadWrite");
		const isLiterate = actor.items.find((item) => item.name === readWrite && item.type === "talent") != null;
		let myRegex = new RegExp(`${game.settings.get("polyglot", "LanguageRegex")}\\s*\\((.+)\\)`, "i");
		for (let item of actor.items) {
			// adding only the descriptive language name, not "Language (XYZ)"
			if (myRegex.test(item.name)) {
				let language = item.name.match(myRegex)[1].trim().toLowerCase();
				knownLanguages.add(language);
				if (isLiterate) literateLanguages.add(language);
			}
		}
		return [knownLanguages, literateLanguages];
	}

	conditions(lang) {
		return game.polyglot.literateLanguages.has(lang);
	}
}

class wwnLanguageProvider extends LanguageProvider {
	get settings() {
		return {
			// System has a built-in setting to handle languages.
			replaceLanguages: {
				polyglotHide: true,
				...game.settings.settings.get("polyglot.replaceLanguages"),
			},
			customLanguages: {
				polyglotHide: true,
				...game.settings.settings.get("polyglot.customLanguages"),
			},
		};
	}

	getSystemDefaultLanguage() {
		return Object.keys(this.languages)[0];
	}

	addLanguage(lang) {
		if (!lang) return;
		let languages = game.settings.get("wwn", "languageList");
		const languagesSetting = game.settings.get("polyglot", "Languages");
		if (!languages.includes(lang)) {
			if (languages.endsWith(",")) languages += lang;
			else languages += `,${lang}`;
			game.settings.set("wwn", "languageList", languages);
		}
		lang = lang.trim();
		const key = lang.toLowerCase().replace(/[\s']/g, "_");
		this.languages[key] = {
			label: lang,
			font: languagesSetting[key]?.font ?? this.defaultFont,
			rng: languagesSetting[key]?.rng ?? "default",
		};
	}

	removeLanguage(lang) {
		if (!lang) return;
		let languages = game.settings.get("wwn", "languageList");
		if (languages.includes(lang)) {
			languages.replace(new RegExp(`,\\s*${lang}`), "");
			game.settings.set("wwn", "languageList", languages);
		}
		const key = lang.trim().toLowerCase().replace(/[\s']/g, "_");
		delete this.languages[key];
	}

	async getLanguages() {
		const languagesSetting = game.settings.get("polyglot", "Languages");
		for (let lang of game.settings.get("wwn", "languageList").split(",")) {
			const key = lang.toLowerCase().replace(/[\s']/g, "_");
			this.languages[key] = {
				label: lang,
				font: languagesSetting[key]?.font || this.defaultFont,
				rng: languagesSetting[key]?.rng ?? "default",
			};
		}
	}

	getUserLanguages(actor) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (actor.system.languages) {
			for (let lang of actor.system.languages.value) {
				knownLanguages.add(lang.toLowerCase());
			}
		}
		return [knownLanguages, literateLanguages];
	}
}

var providers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	LanguageProvider: LanguageProvider,
	GenericLanguageProvider: GenericLanguageProvider,
	a5eLanguageProvider: a5eLanguageProvider,
	ariaLanguageProvider: ariaLanguageProvider,
	arsLanguageProvider: arsLanguageProvider,
	coc7LanguageProvider: coc7LanguageProvider,
	cyberpunkRedLanguageProvider: cyberpunkRedLanguageProvider,
	d35eLanguageProvider: d35eLanguageProvider,
	darkHeresyLanguageProvider: darkHeresyLanguageProvider,
	dccLanguageProvider: dccLanguageProvider,
	demonlordLanguageProvider: demonlordLanguageProvider,
	dnd4eLanguageProvider: dnd4eLanguageProvider,
	dnd5eLanguageProvider: dnd5eLanguageProvider,
	dsa5LanguageProvider: dsa5LanguageProvider,
	earthdawn4eLanguageProvider: earthdawn4eLanguageProvider,
	fggLanguageProvider: fggLanguageProvider,
	gurpsLanguageProvider: gurpsLanguageProvider,
	oseLanguageProvider: oseLanguageProvider,
	pf1LanguageProvider: pf1LanguageProvider,
	pf2eLanguageProvider: pf2eLanguageProvider,
	sfrpgLanguageProvider: sfrpgLanguageProvider,
	shadowrun5eLanguageProvider: shadowrun5eLanguageProvider,
	splittermondLanguageProvider: splittermondLanguageProvider,
	sw5eLanguageProvider: sw5eLanguageProvider,
	swadeLanguageProvider: swadeLanguageProvider,
	tormenta20LanguageProvider: tormenta20LanguageProvider,
	uesrpgLanguageProvider: uesrpgLanguageProvider,
	wfrp4eLanguageProvider: wfrp4eLanguageProvider,
	wwnLanguageProvider: wwnLanguageProvider
});

/** Providers whose systems use "-"" in their names */
const providerKeys = {
	"cyberpunk-red-core": "cyberpunkRed",
	"dark-heresy": "darkHeresy",
	"uesrpg-d100": "uesrpg",
};

class PolyglotAPI {
	constructor() {
		this.providers = {};
		this.polyglot = null;
	}

	init() {
		// Assumes the first class in the file is the actual LanguageProvider class. This is better than adding an if-clause in the loop
		const supportedSystems = Object.keys(providers)
			.filter((provider) => provider !== "LanguageProvider")
			.map((provider) => provider.replace("LanguageProvider", ""))
			.join("|");
		const systemsRegex = new RegExp(`^(${supportedSystems})$`);
		let providerString = game.system.id;
		if (!systemsRegex.test(game.system.id)) {
			providerString = providerKeys[game.system.id] || "Generic";
		}

		const providerId = `native${providerString !== "Generic" ? `.${providerString}` : ""}`;
		this.providers[providerId] = new providers[`${providerString}LanguageProvider`](providerId);
	}

	get languageProvider() {
		return this.polyglot.languageProvider;
	}

	/**
	 * @param {String} provider
	 */
	set languageProvider(provider) {
		this.polyglot.languageProvider = this.providers[provider];
	}

	attach() {
		game.polyglot.api = this;
		this.polyglot = game.polyglot;
	}

	defaultProvider() {
		/** providerIds should always be sorted the same way so this should achieve a stable default. */
		const providerIds = Object.keys(this.providers);
		let defaultValue = providerIds[0];

		const module = providerIds.find((key) => key.startsWith("module."));
		if (module) defaultValue = module;

		const gameSystem = providerIds.find((key) => key.startsWith("system.") || key.includes(game.system.id));
		if (gameSystem) defaultValue = gameSystem;

		addSetting("languageProvider", {
			// Has no name or hint
			config: false,
			type: String,
			default: defaultValue,
			onChange: (s) => {
				this.languageProvider = this.providers[s];
			},
		});
	}

	updateProvider() {
		// If the configured provider is registered use that one. If not use the default provider
		const configuredProvider = game.settings.get("polyglot", "languageProvider");
		const fallbackProvider = game.settings.settings.get("polyglot.languageProvider").default;
		this.polyglot.languageProvider = this.providers[configuredProvider] || this.providers[fallbackProvider];
	}

	/**
	 * @param {String} moduleId
	 * @param {providers.LanguageProvider} languageProvider
	 */
	registerModule(moduleId, languageProvider) {
		const module = game.modules.get(moduleId);
		if (!module) {
			console.warn(
				`Polyglot | A module tried to register with the id "${moduleId}". However no active module with this id was found. This api registration call was ignored. If you are the author of that module please check that the id passed to "registerModule" matches the id in your manifest exactly.`,
			);
			return;
		}
		if (moduleId === "polyglot") {
			console.warn(
				`Polyglot | A module tried to register with the id "${moduleId}", which is not allowed. This api registration call was ignored. If you're the author of the module please use the id of your own module as it's specified in your manifest to register to this api.`,
			);
			return;
		}

		this.#register(`module.${module.id}`, languageProvider);
	}

	/**
	 * @param {providers.LanguageProvider} languageProvider
	 */
	registerSystem(languageProvider) {
		this.#register(`system.${game.system.id}`, languageProvider);
	}

	/**
	 * @param {String} id
	 * @param {providers.LanguageProvider} languageProvider
	 */
	#register(id, languageProvider) {
		const providerInstance = new languageProvider(id);
		this.providers[providerInstance.id] = providerInstance;
	}
}

/* eslint-disable no-unused-vars */
class PolyglotHooks {
	/**
	 * Adds the Languages selector to the chatlog.
	 */
	static renderChatLog(chatlog, html, data) {
		game.polyglot.renderChatLog = true;
		const input = game.settings.get("polyglot", "displayCheckbox")
			? `<input name="polyglot-checkbox" type="checkbox" ${game.settings.get("polyglot", "checkbox") ? "checked" : ""}>`
			: "";
		html.find("#chat-controls").after(
			`<div id='polyglot' class='polyglot polyglot-lang-select flexrow'>
				${input}
				<label>${game.i18n.localize("POLYGLOT.LanguageLabel")}</label>
				<select name='polyglot-language'></select>
			</div>`,
		);
		html.find(".polyglot-lang-select select").change((ev) => {
			const lang = ev.target.value;
			game.polyglot.lastSelection = lang;
		});
		html.find("input[name='polyglot-checkbox']").change((ev) => {
			game.settings.set("polyglot", "checkbox", ev.target.checked);
		});
		game.polyglot.updateUserLanguages(html);
	}

	static updateActor(actor, data, options, userId) {
		if (actor.hasPlayerOwner && actor.testUserPermission(game.user, "OWNER")) {
			game.polyglot.updateUserLanguages();
			game.polyglot.updateChatMessages();
		}
	}

	static controlToken() {
		game.polyglot.updateUserLanguages();
		game.polyglot.updateChatMessages();
	}

	/**
	 * Updates the languages in the Languages selector and the messages that are readable by the character.
	 */
	static updateUser(user, data, options, userId) {
		if (user.id === userId && data.character !== undefined) {
			PolyglotHooks.controlToken();
		}
		if (data.flags?.polyglot) {
			game.polyglot.languageProvider.getDefaultLanguage();
		}
	}

	static updateActiveEffect() {
		PolyglotHooks.controlToken();
	}

	/**
	 * Adds the selected language to the message's flag.
	 * @param {ChatMessage} message
	 * @param {Object} data
	 * @param {Object} options
	 * @param {String} userId
	 * @returns {Boolean}
	 */
	static preCreateChatMessage(message, data, options, userId) {
		const isCheckboxEnabled = !game.settings.get("polyglot", "displayCheckbox")
			|| game.polyglot.chatElement.find("input[name=polyglot-checkbox]").prop("checked");
		const isMessageLink = game.polyglot._isMessageLink(data.content);
		const isMessageInlineRoll = /\[\[(.*?)\]\]/g.test(data.content);
		// Message preprended by /desc from either Cautious GM Tools or Narrator Tools modules
		const isDescMessage =
			message.flags?.cgmp?.subType === 1
			|| ["description", "narration", "notification"].includes(message.flags?.["narrator-tools"]?.type);
		if (!isCheckboxEnabled || isMessageLink || isMessageInlineRoll || isDescMessage) return true;
		if (
			message.style === CONST.CHAT_MESSAGE_STYLES.IC
			|| (message.style === CONST.CHAT_MESSAGE_STYLES.OOC && game.polyglot._allowOOC())
		) {
			let lang = game.polyglot.chatElement.find("select[name=polyglot-language]").val();
			const language = data.lang || data.language;
			if (language) {
				if (game.polyglot.languageProvider.languages[language]) {
					lang = language;
				} else {
					Object.values(game.polyglot.languageProvider.languages).every((l) => {
						if (language === l.label) {
							lang = language;
							return false;
						}
						return true;
					});
				}
			}
			if (lang) {
				message.updateSource({ "flags.polyglot.language": lang });
			}
		}
	}

	/**
	 * Renders the messages, scrambling the text if it is not known by the user (or currently selected character)
	 * and adding the indicators ("Translated From" text and the globe icon).
	 *
	 * @param {ChatMessage} message		The ChatMessage document being rendered
	 * @param {JQuery} html 			The pending HTML as a jQuery object
	 * @param {Object} data 					The input data provided for template rendering
	 *
	 * @var {Boolean} known				Determines if the actor actually knows the language, rather than being affected by Comprehend Languages or Tongues
	 */
	static async renderChatMessage(message, html, data) {
		const lang = message.getFlag("polyglot", "language");
		if (!lang) return;

		if (game.polyglot.languageProvider.requiresReady && !game.ready) {
			Hooks.once("polyglot.languageProvider.ready", async () => {
				await PolyglotHooks.renderChatMessage(message, html, data);
			});
			return;
		}
		// Skip for inline rolls
		if (!game.polyglot.knownLanguages.size) game.polyglot.updateUserLanguages();
		const metadata = html.find(".message-metadata");
		const language = game.polyglot.languageProvider.languages?.[lang]?.label || lang;
		const known = game.polyglot.isLanguageKnown(lang);
		const understood = game.polyglot.isLanguageUnderstood(lang);
		const isGM = game.user.isGM;
		const runifyGM = game.settings.get("polyglot", "runifyGM");
		const displayTranslated = game.settings.get("polyglot", "display-translated");
		const hideTranslation = game.settings.get("polyglot", "hideTranslation");
		if (isGM && !runifyGM) message.polyglot_unknown = false;
		else {
			message.polyglot_unknown =
				!game.polyglot._isTruespeech(lang) && !known && (game.user.character || isGM ? !understood : true);
		}
		const forceTranslation = message.polyglot_force || !message.polyglot_unknown;
		const messageContent = html.find(".message-content");
		const innerText = messageContent.text().trim();

		const content = $("<div>")
			.addClass("polyglot-original-text")
			.css({ font: game.polyglot._getFontStyle(lang) })
			.html(game.polyglot.scrambleString(innerText, message.id, lang));
		const translation = $("<div>")
			.addClass("polyglot-translation-text")
			.attr("data-tooltip", language)
			.attr("data-tooltip-direction", "UP")
			.html(message.content);

		if (
			displayTranslated
			&& (lang !== game.polyglot.languageProvider.defaultLanguage || message.polyglot_unknown)
		) {
			messageContent.empty().append(content);

			if (
				forceTranslation
				|| (!game.polyglot._isTruespeech(lang) && !message.polyglot_unknown && (isGM || !hideTranslation))
			) {
				messageContent.append(translation);
			}
		} else if (!forceTranslation && message.polyglot_unknown) {
			messageContent.empty().append(content);
		}

		if (isGM || ((known || understood) && !hideTranslation)) {
			let color = "red";
			if ((isGM && !runifyGM) || known) color = "green";
			else if (understood) color = "blue";
			const title =
				isGM || known || game.polyglot._isTruespeech(lang)
					? `data-tooltip="${language}" data-tooltip-direction="LEFT"`
					: "";
			const clickable = isGM && (runifyGM || !displayTranslated);
			const button = $(`<a class="polyglot-message-language ${clickable ? "" : "unclickable"}" ${title}>
				<i class="fas fa-globe" style="color:${color}"></i>
			</a>`);
			metadata.find(".polyglot-message-language").remove();
			metadata.append(button);
			if (clickable) {
				button.on("click", game.polyglot._onGlobeClick.bind(this));
			}
		}
	}

	/**
	 * This is required for when Polyglot tries to update messages that have no language set.
	 * This is essential for compatibility with modules that create messages (see https://github.com/mclemente/fvtt-module-polyglot/pull/285).
	 * @param {ChatMessage} message
	 * @param {Object} options
	 * @param {String} userId
	 * @returns {Boolean}
	 */
	static createChatMessage(message, options, userId) {
		return !(game.polyglot._isMessageLink(message.content)
			|| (message.style === CONST.CHAT_MESSAGE_STYLES.OOC && !game.polyglot._allowOOC()));
	}

	/**
	 * Adds the scrambling button to the document's header in case user is the owner and scrambles text written in languages.
	 * Special case for Pages due to their ownership working a bit differently.
	 *
	 * @param {Document} journalTextPageSheet		A JournalTextPageSheet document.
	 * @param {*} param1
	 * @param {*} data
	 * @returns
	 */
	static renderDocumentSheet(sheet, html, data) {
		const isOwnerOrGM = sheet.document?.isOwner || game.user.isGM;
		const isEditable = data.editable;
		const isTextSheet = sheet instanceof JournalTextPageSheet;

		if (isTextSheet && !(sheet.object.parent.isOwner || isOwnerOrGM || isEditable)) {
			if (sheet.document.isOwner) game.polyglot.insertHeaderButton(sheet.object.parent.sheet, html);
			else game.polyglot.scrambleSpans(sheet, html);
		} else if (html.find(".polyglot-journal").length) {
			if (isOwnerOrGM && html.find('[data-engine="prosemirror"]').length) game.polyglot.insertHeaderButton(sheet, html);
			else if (!(isOwnerOrGM || isEditable)) game.polyglot.scrambleSpans(sheet, html);
		}
	}

	/** @see renderDocumentSheet */
	static renderActorSheet(sheet, html, data) {
		PolyglotHooks.renderDocumentSheet(sheet, html, data);
	}

	/** @see renderDocumentSheet */
	static renderItemSheet(sheet, html, data) {
		PolyglotHooks.renderDocumentSheet(sheet, html, data);
	}

	/** @see renderDocumentSheet */
	static renderJournalTextPageSheet(journalTextPageSheet, html, data) {
		PolyglotHooks.renderDocumentSheet(journalTextPageSheet, html, data);
	}

	/**
	 * Renders a journal entry, adding the scrambling button to its header in case user is the document's owner or a GM.
	 *
	 * @param {Document} sheet		A JournalSheet document.
	 * @param {HTMLElement} html
	 */
	static renderJournalSheet(sheet, html) {
		CONFIG.TinyMCE.style_formats.find((f) => f.title === "Polyglot").items = game.polyglot.getLanguagesForEditor();
		if ((sheet.document?.isOwner || game.user.isGM) && sheet.document.pages.size) {
			game.polyglot.insertHeaderButton(sheet, html);
		}
	}

	/** @see renderJournalSheet */
	static renderStorySheet(sheet, html) {
		PolyglotHooks.renderJournalSheet(sheet, html);
	}

	static getProseMirrorMenuDropDowns(menu, items) {
		if ("format" in items) {
			if ("format" in items) {
				items.format.entries.push({
					action: "polyglot",
					title: "Polyglot",
					children: game.polyglot.getLanguagesForEditor()
						.map((l) => {
							return {
								action: l.attributes["data-language"],
								title: l.title,
								mark: menu.schema.marks.span,
								attrs: { class: "polyglot-journal", ...l.attributes },
								cmd: ProseMirror.commands.toggleMark(menu.schema.marks.span, {
									_preserve: {
										class: "polyglot-journal",
										...l.attributes
									}
								})
							};
						})
				});
			}
		}
	}

	// Re-checks the user languages for the GM when activating another party on the Actors sidebar.
	static renderActorDirectoryPF2e(actors, html, data) {
		game.polyglot.updateUserLanguages();
	}

	/**
	 * Scrambles the text of vino messages.
	 * @param {*} chatDisplayData
	 */
	static vinoPrepareChatDisplayData(chatDisplayData) {
		const message = chatDisplayData.message;
		const lang = message.getFlag("polyglot", "language");

		if (lang) {
			const isLanguageUnknown = !game.polyglot.isLanguageknownOrUnderstood(lang);
			message.polyglot_unknown = isLanguageUnknown;
			if (game.user.isGM && !game.settings.get("polyglot", "runifyGM")) message.polyglot_unknown = false;
			if (!message.polyglot_force && message.polyglot_unknown) {
				const newContent = game.polyglot.scrambleString(chatDisplayData.text, message.id, lang);
				chatDisplayData.text = newContent;
				chatDisplayData.font = game.polyglot._getFontStyle(lang);
				chatDisplayData.skipAutoQuote = true;
			}
		}
	}
}

// SPDX-License-Identifier: MIT

// A shim for the libWrapper library
let libWrapper = undefined;
const TGT_SPLIT_RE = new RegExp("([^.[]+|\\[('([^'\\\\]|\\\\.)+?'|\"([^\"\\\\]|\\\\.)+?\")\\])", "g");
const TGT_CLEANUP_RE = new RegExp("(^\\['|'\\]$|^\\[\"|\"\\]$)", "g");

// Main shim code
Hooks.once("init", () => {
	// Check if the real module is already loaded - if so, use it
	if (globalThis.libWrapper && !(globalThis.libWrapper.is_fallback ?? true)) {
		libWrapper = globalThis.libWrapper;
		return;
	}

	// Fallback implementation
	libWrapper = class {
		static get is_fallback() {
			return true;
		}

		static get WRAPPER() {
			return "WRAPPER";
		}

		static get MIXED() {
			return "MIXED";
		}

		static get OVERRIDE() {
			return "OVERRIDE";
		}

		static register(package_id, target, fn, type = "MIXED", { chain = undefined, bind = [] } = {}) {
			const is_setter = target.endsWith("#set");
			target = !is_setter ? target : target.slice(0, -4);
			const split = target.match(TGT_SPLIT_RE).map((x) => x.replace(/\\(.)/g, "$1").replace(TGT_CLEANUP_RE, ""));
			const root_nm = split.splice(0, 1)[0];

			let obj; let fn_name;
			if (split.length === 0) {
				obj = globalThis;
				fn_name = root_nm;
			} else {
				const _eval = eval;
				fn_name = split.pop();
				obj = split.reduce((x, y) => x[y], globalThis[root_nm] ?? _eval(root_nm));
			}

			let iObj = obj;
			let descriptor = null;
			while (iObj) {
				descriptor = Object.getOwnPropertyDescriptor(iObj, fn_name);
				if (descriptor) break;
				iObj = Object.getPrototypeOf(iObj);
			}
			if (!descriptor || descriptor?.configurable === false) throw new Error(
					`libWrapper Shim: '${target}' does not exist, could not be found, or has a non-configurable descriptor.`,
				);

			let original = null;
			const wrapper =
				chain ?? (type.toUpperCase?.() !== "OVERRIDE" && type !== 3)
					? function (...args) {
							return fn.call(this, original.bind(this), ...bind, ...args);
					  }
					: function (...args) {
							return fn.call(this, ...bind, ...args);
					  };
			if (!is_setter) {
				if (descriptor.value) {
					original = descriptor.value;
					descriptor.value = wrapper;
				} else {
					original = descriptor.get;
					descriptor.get = wrapper;
				}
			} else {
				if (!descriptor.set) throw new Error(`libWrapper Shim: '${target}' does not have a setter`);
				original = descriptor.set;
				descriptor.set = wrapper;
			}

			descriptor.configurable = true;
			Object.defineProperty(obj, fn_name, descriptor);
		}
	};
});

class Polyglot {
	constructor() {
		this.knownLanguages = new Set();
		this.literateLanguages = new Set();
		this.refreshTimeout = null;
		this.FONTS = getFonts();
		// TODO consider removing this variable and let LanguageProvider handle it instead
		this.CustomFontSizes = game.settings.get("polyglot", "CustomFontSizes");
		CONFIG.fontDefinitions = foundry.utils.mergeObject(CONFIG.fontDefinitions, this.FONTS);
	}

	init() {
		for (let hook of Object.getOwnPropertyNames(PolyglotHooks)) {
			if (!["length", "name", "prototype"].includes(hook)) {
				Hooks.on(hook, PolyglotHooks[hook]);
			}
		}
		Polyglot.handleTinyMCE();

		libWrapper.register(
			"polyglot",
			"ChatBubbles.prototype.say",
			async (wrapped, token, message, { cssClasses, requireVisible = false, pan = true, language = "" } = {}) => {
				if (game.user.isGM && !game.settings.get("polyglot", "runifyGM")) {
					return wrapped(token, message, { cssClasses, requireVisible, pan });
				}
				let lang = "";
				let randomId = "";
				if (language) {
					randomId = foundry.utils.randomID(16);
					if (this.languageProvider.languages[language]) {
						lang = language;
					} else {
						Object.values(this.languageProvider.languages).every((l) => {
							if (language === l.label) {
								lang = language;
								return false;
							}
							return true;
						});
					}
				} else {
					// Find the message out of the last 10 chat messages, last to first
					const msg = game.messages.contents
						.slice(-10)
						.reverse()
						.find(
							(m) => m.content === message && m.style === CONST.CHAT_MESSAGE_STYLES.IC
						);
					// Message was sent in-character (no /ooc or /emote)
					if (msg) {
						lang = msg.getFlag("polyglot", "language") || "";
						randomId = msg.id;
					}
				}
				// Language isn't truespeech, isn't known and user isn't under Comprehend Languages effect
				if (lang && !this.isLanguageknownOrUnderstood(lang)) {
					message = this.scrambleString(message, randomId, lang);
					document.documentElement.style.setProperty(
						"--polyglot-chat-bubble-font",
						this._getFontStyle(lang).replace(/\d+%\s/g, ""),
					);
					if (cssClasses === undefined) cssClasses = [];
					cssClasses.push("polyglot", "polyglot-chat-bubble");
				}
				return wrapped(token, message, { cssClasses, requireVisible, pan });
			},
			"WRAPPER",
		);
	}

	get chatElement() {
		return ui.sidebar.popouts.chat?.element || ui.chat.element;
	}

	/**
	 * @returns {object}
	 */
	get alphabets() {
		return this.languageProvider.alphabets;
	}

	/**
	 * Returns an object or array, based on the game system's own data structure.
	 *
	 * @returns {object|array}
	 */
	get languages() {
		return this.languageProvider.languages;
	}

	/**
	 * @returns {String}
	 */
	get defaultLanguage() {
		return this.languageProvider.defaultLanguage;
	}

	get omniglot() {
		return this._omniglot.trim().toLowerCase().replace(/[\s']/g, "_");
	}

	set omniglot(lang) {
		if (lang === this._omniglot) return;
		this.languageProvider.removeLanguage(this._omniglot);
		this.languageProvider.addLanguage(lang);
		this._omniglot = lang;
	}

	get comprehendLanguages() {
		return this._comprehendLanguages.trim().toLowerCase().replace(/[\s']/g, "_");
	}

	set comprehendLanguages(lang) {
		if (lang === this._comprehendLanguages) return;
		this.languageProvider.removeLanguage(this._comprehendLanguages);
		this.languageProvider.addLanguage(lang);
		this._comprehendLanguages = lang;
	}

	get truespeech() {
		return this._truespeech.trim().toLowerCase().replace(/[\s']/g, "_");
	}

	set truespeech(lang) {
		if (lang === this._truespeech) return;
		this.languageProvider.removeLanguage(this._truespeech);
		this.languageProvider.addLanguage(lang);
		this._truespeech = lang;
	}

	/* -------------------------------------------- */
	/*  Hooks	                                    */
	/* -------------------------------------------- */

	/**
	 * Updates the chat messages.
	 * It has a delay because switching tokens could cause a controlToken(false) then controlToken(true) very fast.
	 */
	updateChatMessages() {
		if (this.refreshTimeout) clearTimeout(this.refreshTimeout);
		this.refreshTimeout = setTimeout(this.updateChatMessagesDelayed.bind(this), 500);
	}

	/**
	 * Updates the last 100 messages. Loop in reverse so most recent messages get refreshed first.
	 */
	updateChatMessagesDelayed() {
		this.refreshTimeout = null;
		const messages = game.messages.contents
			.slice(-CONFIG.ChatMessage.batchSize)
			.map((m) => game.messages.get(m.id));
		for (const message of messages) {
			if (
				message.style === CONST.CHAT_MESSAGE_STYLES.IC
				|| (message.style === CONST.CHAT_MESSAGE_STYLES.OOC && message.getFlag("polyglot", "language"))
			) {
				ui.chat.updateMessage(message);
			}
		}
	}

	getUserLanguages(actors = []) {
		let knownLanguages = new Set();
		let literateLanguages = new Set();
		if (actors.length === 0) {
			if (canvas && canvas.tokens) {
				for (let token of canvas.tokens.controlled) {
					if (token.actor) actors.push(token.actor);
				}
			}
			if (actors.length === 0 && game.user.character) actors.push(game.user.character);
		}
		for (let actor of actors) {
			try {
				[knownLanguages, literateLanguages] = this.languageProvider.getUserLanguages(actor);
			} catch(err) {
				console.error(`Polyglot | Failed to get languages from actor "${actor.name}".`, err);
			}
		}
		return [knownLanguages, literateLanguages];
	}

	/**
	 *
	 * @param {*} html
	 *
	 * @var {Set} this.knownLanguages
	 */
	updateUserLanguages() {
		if (game.polyglot.languageProvider.requiresReady && !game.ready) return;
		[this.knownLanguages, this.literateLanguages] = this.getUserLanguages();
		const defaultLanguage = this.defaultLanguage;
		if (this.knownLanguages.size === 0) {
			if (game.user.isGM) this.knownLanguages = new Set(Object.keys(this.languageProvider.languages).sort());
			else this.knownLanguages.add(defaultLanguage);
		} else if (this.knownLanguages.has(this.omniglot)) {
			this.knownLanguages = new Set(Object.keys(this.languageProvider.languages).sort());
		}

		if (!game.polyglot.renderChatLog) return;
		let options = [];
		let ownedActors = [];
		if (game.user.isGM) {
			// GM's list has optgroups separated between known and unknown.
			options.push(...[
				{
					id: "known",
					text: game.i18n.localize("POLYGLOT.KnownLanguages"),
					children: []
				},
				{
					id: "unknown",
					text: game.i18n.localize("POLYGLOT.UnknownLanguages"),
					children: []
				}
			]);
			ownedActors = game.actors.filter((actor) => actor.hasPlayerOwner);
			for (const actor of ownedActors) {
				actor.knownLanguages = this.getUserLanguages([actor])[0];
				if (
					actor.knownLanguages.has(this.omniglot)
					|| actor.knownLanguages.has(this.truespeech)
					|| actor.knownLanguages.has(this.comprehendLanguages)
				) {
					actor.knownLanguages = new Set(Object.keys(this.languageProvider.languages).sort());
				} else if (this.truespeech) {
					actor.knownLanguages.add(this.truespeech);
				}
			}
		}
		const filteredUsers = this.languageProvider.filterUsers(ownedActors);
		for (let lang of this.knownLanguages) {
			if (!this._isTruespeech(lang) && (lang === this.omniglot || lang === this.comprehendLanguages)) {
				continue;
			}
			const label = this.languageProvider.languages[lang]?.label || lang.capitalize();
			if (game.user.isGM) {
				if (ownedActors.length) {
					const usersThatKnowLang = filteredUsers.filter((u) =>
						ownedActors.some((actor) => actor.knownLanguages.has(lang) && actor.testUserPermission(u, "OWNER")),
					);
					const usersWithOwnedActors = usersThatKnowLang.map((u) => {
						const actorsOwnedByUser = ownedActors
							.filter((actor) => actor.knownLanguages.has(lang) && actor.testUserPermission(u, "OWNER"))
							.map((a) => a.name);
						return { ...u, actorsOwnedByUser };
					});
					if (usersWithOwnedActors.length) {
						let users = [];
						for (let user of usersWithOwnedActors) {
							const { name, color, actorsOwnedByUser } = user;
							users.push({ bgColor: color, userName: name, ownedActors: actorsOwnedByUser.join(", ") });
						}
						options[0].children.push({
							id: lang,
							text: label,
							users,
						});
						continue;
					}
				}
				options[1].children.push({
					id: lang,
					text: label,
				});
			} else {
				options.push({
					id: lang,
					text: label,
				});
			}
		}
		// Remove childless lists. Otherwise, sort them by label
		if (game.user.isGM) {
			if (!options[1].children.length) {
				options.pop();
			} else {
				options[1].children.sort((a, b) => a.text.localeCompare(b.text));
			}
			if (!options[0].children.length) {
				options.shift();
			} else {
				options[0].children.sort((a, b) => a.text.localeCompare(b.text));
			}
		} else {
			options.sort((a, b) => a.text.localeCompare(b.text));
		}

		const select = this.chatElement.find(".polyglot-lang-select select");
		const prevOption = select.val();

		select.empty();

		const formatState = (state) => {
			const { id, text, users } = state;
			let $state = text;
			if (id && users) {
				let userList = [];
				for (let user of users) {
					const { bgColor, userName, ownedActors } = user;
					const tooltip = `${userName} (${ownedActors})`;
					userList.push(
						`<div style="background-color: ${bgColor};" data-tooltip="${tooltip}" data-tooltip-direction="UP"></div>`,
					);
				}
				$state = $(
					`<div class="flexrow">
						<div>${text}</div>
						<div class="polyglot polyglot-user-list">${userList.join("")}</div>
					</div>`.trim(),
				);
			}
			return $state;
		};

		// This is needed in case a system or another module already defined select2 under version 4.1, which doesn't accept dropdownCssClass
		try {
			select.select2({
				data: options,
				dropdownCssClass: "polyglot-language",
				templateResult: formatState,
				templateSelection: formatState,
			});
		} catch(error) {
			if (error.message.includes("No select2/compat/dropdownCss")) {
				select.select2({
					data: options,
					templateResult: formatState,
					templateSelection: formatState,
				});
			} else {
				console.error(error);
			}
		} finally {
			$(document).on("mouseenter", ".select2-selection__rendered", function () {
				$(this).removeAttr("title");
			});

			let selectedLanguage = this.lastSelection || prevOption || defaultLanguage;
			if (!this.isLanguageKnown(selectedLanguage)) {
				if (this.isLanguageKnown(defaultLanguage)) selectedLanguage = defaultLanguage;
				else selectedLanguage = [...this.knownLanguages][0];
			}
			select.val(selectedLanguage).trigger("change.select2");
		}
	}

	/**
	 * Generates a string using alphanumeric characters (0-9a-z)
	 * Use a seeded PRNG (pseudorandom number generator) to get consistent scrambled results.
	 *
	 * @param {string} string	The message's text.
	 * @param {string} salt		The message's id, if Randomize Runes setting is enabled (to make no two messages equal), or its language.
	 * @return {string}			The message's text with its characters scrambled by the PRNG.
	 */
	scrambleString(string, salt, lang) {
		let language = this.languageProvider.languages[lang];
		const rng = language?.rng ?? "default";
		if (rng === "none") return string;
		if (rng === "default") salt = lang;
		// const font = this._getFontStyle(lang).replace(/\d+%\s/g, "");
		const font = this.languageProvider.getLanguageFont(lang);
		const selectedFont = this.languageProvider.fonts[font];
		if (!selectedFont) {
			console.error(`Invalid font style '${font}'`);
			return string;
		}

		const salted_string = string + salt;
		const seed = new foundry.dice.MersenneTwister(this._hashCode(salted_string));
		const regex = game.settings.get("polyglot", "RuneRegex") ? /[a-zA-Z\d]/g : /\S/gu;
		const characters = selectedFont.alphabeticOnly
			? "abcdefghijklmnopqrstuvwxyz"
			: "abcdefghijklmnopqrstuvwxyz0123456789";

		// if (selectedFont.replace) {
		// 	Object.keys(selectedFont.replace).forEach((key) => {
		// 		const replaceRegex = new RegExp(key, "g");
		// 		string = string.replace(replaceRegex, selectedFont.replace[key]);
		// 	});
		// }
		if (selectedFont.logographical) {
			string = string.substring(0, Math.round(string.length / 2));
		}
		return string.replace(regex, () => {
			const c = characters.charAt(Math.floor(seed.random() * characters.length));
			const upper = Boolean(Math.round(seed.random()));
			return upper ? c.toUpperCase() : c;
		});
	}

	/**
	 * Registers settings, adjusts the bubble dimensions so the message is displayed correctly,
	 * and loads the current languages set for Comprehend Languages Spells and Tongues Spell settings.
	 */
	ready() {
		function checkChanges() {
			const alphabetsSetting = game.settings.get("polyglot", "Alphabets");
			const languagesSetting = game.settings.get("polyglot", "Languages");
			const { fonts, languages } = game.polyglot.languageProvider;
			if (
				!foundry.utils.isEmpty(foundry.utils.diffObject(alphabetsSetting, fonts))
				|| !foundry.utils.isEmpty(foundry.utils.diffObject(fonts, alphabetsSetting))
			) {
				game.settings.set("polyglot", "Alphabets", fonts);
			}
			if (
				!foundry.utils.isEmpty(foundry.utils.diffObject(languagesSetting, languages))
				|| !foundry.utils.isEmpty(foundry.utils.diffObject(languages, languagesSetting))
			) {
				game.settings.set("polyglot", "Languages", languages);
			}
		}
		if (this.languageProvider.requiresReady) {
			Hooks.once("polyglot.languageProvider.ready", () => {
				this.updateUserLanguages();
				checkChanges();
			});
		} else checkChanges();
	}

	/* -------------------------------------------- */
	/*  Helpers				                        */
	/* -------------------------------------------- */

	/**
	 *
	 * @param {Document} document
	 * @param {HTMLElement} html
	 */
	insertHeaderButton(document, html) {
		const toggleButton = this.createHeaderButton(document);
		html.closest(".app").find(".polyglot-button").remove();
		const titleElement = html.closest(".app").find(".window-title");
		toggleButton.insertAfter(titleElement);
	}

	/**
	 * Creates the Header button for Documents.
	 * @param {Document} document 	A JournalSheet or JournalTextPageSheet
	 * @returns {} toggleButton
	 */
	createHeaderButton(document) {
		let runes = false;
		let texts = [];
		let styles = [];
		const toggleString = `<a class='polyglot-button'
			data-tooltip='Polyglot: ${game.i18n.localize("POLYGLOT.ToggleRunes")}' data-tooltip-direction="UP">
			<i class='fas fa-unlink'></i>
		</a>`;
		const toggleButton = $(toggleString);
		const IgnoreJournalFontSize = game.settings.get("polyglot", "IgnoreJournalFontSize");
		toggleButton.click((ev) => {
			ev.preventDefault();
			let button = ev.currentTarget.firstChild;
			runes = !runes;
			button.className = runes ? "fas fa-link" : "fas fa-unlink";
			const spans = document.element.find("span.polyglot-journal");
			if (runes) {
				for (let span of spans.toArray()) {
					const lang = span.dataset.language;
					if (!lang) continue;
					texts.push(span.textContent);
					let spanStyle = {
						fontFamily: span.style.fontFamily,
						fontSize: span.style.fontSize,
						font: span.style.font,
					};
					if (span.children.length && span.children[0].nodeName === "SPAN") {
						spanStyle = {
							fontFamily: span.children[0].style.fontFamily,
							fontSize: span.children[0].style.fontSize,
							font: span.children[0].style.font,
						};
					}
					styles.push(spanStyle);
					span.textContent = this.scrambleString(span.textContent, document.id, lang);
					if (IgnoreJournalFontSize) span.style.fontFamily = this._getFontStyle(lang).replace(/\d+%\s/g, "");
					else span.style.font = this._getFontStyle(lang);
				}
			} else {
				let i = 0;
				for (let span of spans.toArray()) {
					const lang = span.dataset.language;
					if (!lang) continue;
					span.textContent = texts[i];
					if (styles[i].font) {
						span.style.font = styles[i].font;
					} else {
						span.style.fontFamily = styles[i].fontFamily;
						span.style.fontSize = styles[i].fontSize;
					}
					i++;
				}
				texts = [];
				styles = [];
			}
		});
		return toggleButton;
	}

	/**
	 *
	 * @param {Document} document
	 * @param {HTMLElement} html
	 */
	scrambleSpans(document, html) {
		// eslint-disable-next-line no-unused-vars
		const [header, text, section] = html;
		const spans = section ? section.querySelectorAll("span.polyglot-journal") : header.querySelectorAll("span.polyglot-journal");
		spans.forEach((e) => {
			const lang = e.dataset.language;
			if (!lang) return;
			const conditions = !game.polyglot._isTruespeech(lang)
				&& !game.polyglot.isLanguageKnown(game.polyglot.comprehendLanguages)
				&& !game.polyglot.languageProvider.conditions(lang);
			if (conditions) {
				e.dataset.tooltip = "????";
				e.textContent = game.polyglot.scrambleString(e.textContent, document.id, lang);
				e.style.font = game.polyglot._getFontStyle(lang);
			}
		});
	}

	isLanguageKnown(lang) {
		return this.knownLanguages.has(lang);
	}

	isLanguageUnderstood(lang) {
		return (
			this.knownLanguages.has(this.omniglot)
			|| this.knownLanguages.has(this.comprehendLanguages)
			|| this.knownLanguages.has(this.truespeech)
			|| this._isOmniglot(lang)
			|| this._isTruespeech(lang)
		);
	}

	/**
	 *
	 * @param {String} lang
	 * @returns {Boolean}
	 */
	isLanguageknownOrUnderstood(lang) {
		return this.isLanguageKnown(lang) || this.isLanguageUnderstood(lang);
	}

	/* -------------------------------------------- */
	/*  Internal Helpers	                        */
	/* -------------------------------------------- */

	_allowOOC() {
		switch (game.settings.get("polyglot", "allowOOC")) {
			case "a":
				return true;
			case "b":
				return game.user.isGM;
			case "c":
				return [CONST.USER_ROLES.TRUSTED, CONST.USER_ROLES.PLAYER].includes(game.user.role);
			default:
				return false;
		}
	}

	/**
	 * Generates a hash based on the input string to be used as a seed.
	 *
	 * @author https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
	 *
	 * @param {string} string 	The salted string.
	 * @returns {int}
	 */
	_hashCode(string) {
		let hash = 0;
		for (let i = 0; i < string.length; i++) {
			const char = string.charCodeAt(i);
			hash = (hash << 5) - hash + char;
			hash = hash & hash;
		}
		return hash;
	}

	/**
	 * Determines if the message content is a link.
	 * @param {String} messageContent
	 * @returns {Boolean} - Whether the message content is a link to an image file or not.
	 */
	_isMessageLink(messageContent) {
		return /@|https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/gi.test(
			messageContent,
		);
	}

	_isOmniglot(lang) {
		return lang === this.omniglot;
	}

	/**
	 * Returns if the language is the target of the Tongues Spell setting.
	 *
	 * @param {string} lang
	 * @returns {Boolean}
	 */
	_isTruespeech(lang) {
		return lang === this.truespeech;
	}

	_onGlobeClick(event) {
		event.preventDefault();
		const li = $(event.currentTarget).parents(".message");
		const message = Messages.instance.get(li.data("messageId"));
		message.polyglot_force = !message.polyglot_force;
		ui.chat.updateMessage(message);
	}

	/**
	 *
	 * @param {string} lang 	A message's polyglot.language flag.
	 * @returns 				The alphabet of the lang or the default alphabet.
	 */
	_getFontStyle(lang) {
		const langFont = this.languageProvider.getLanguageFont(lang);
		const defaultFont = this.languageProvider.defaultFont;
		const font = this.languageProvider.fonts[langFont] || this.languageProvider.fonts[defaultFont];
		return `${font.fontSize}% ${font.fontFamily}`;
	}

	/* -------------------------------------------- */
	/*  Journal Editor		                        */
	/* -------------------------------------------- */

	static handleTinyMCE() {
		// Add Polyglot to TinyMCE's menu
		CONFIG.TinyMCE.style_formats.push({
			title: "Polyglot",
			items: {},
		});
		// Add custom config to remove spans from polyglot when needed
		const removeFormat = [
			{
				selector: "span",
				classes: "polyglot-journal",
				attributes: ["title", "class", "data-language"],
				remove: "all",
				split: true,
				expand: false,
				deep: true,
			},
		];
		if (!CONFIG.TinyMCE.formats) {
			CONFIG.TinyMCE.formats = {
				removeformat: removeFormat,
			};
		} else if (!CONFIG.TinyMCE.formats.removeformat) CONFIG.TinyMCE.formats.removeformat = [...removeFormat];
		else CONFIG.TinyMCE.formats.removeformat.push(...removeFormat);
	}

	getLanguagesForEditor() {
		let langs = this.languageProvider.languages;
		if (!game.user.isGM) {
			langs = {};
			for (let lang of this.knownLanguages) {
				const data = this.languageProvider.languages[lang];
				if (data) {
					langs[lang] = this.languageProvider.languages[lang];
				}
			}
			for (let lang of this.literateLanguages) {
				const data = this.languageProvider.languages[lang];
				if (data) {
					langs[lang] = this.languageProvider.languages[lang];
				}
			}
		}
		const languages = Object.entries(langs)
			.filter(([key]) => typeof langs[key] !== "undefined")
			.map(([key, lang]) => {
				return {
					title: lang.label || "",
					inline: "span",
					classes: "polyglot-journal",
					attributes: {
						"data-tooltip": lang.label || "",
						"data-tooltip-direction": "UP",
						"data-language": key || "",
					},
				};
			});
		if (this.truespeech) {
			const truespeechIndex = languages.findIndex(
				(element) => element.attributes["data-language"] === this.truespeech,
			);
			if (truespeechIndex !== -1) languages.splice(truespeechIndex, 1);
		}
		if (this.comprehendLanguages && !this._isTruespeech(this.comprehendLanguages)) {
			const comprehendLanguagesIndex = languages.findIndex(
				(element) => element.attributes["data-language"] === this.comprehendLanguages,
			);
			if (comprehendLanguagesIndex !== -1) languages.splice(comprehendLanguagesIndex, 1);
		}
		return languages;
	}

	/* -------------------------------------------- */
	/*  Legacy Support	                            */
	/* -------------------------------------------- */

	activeEditorLogic() {}

	get known_languages() {
		return this.knownLanguages;
	}

	get literate_languages() {
		return this.literateLanguages;
	}

	get LanguageProvider() {
		return this.languageProvider;
	}
}

// SPDX-FileCopyrightText: 2022 Johannes Loher
//
// SPDX-License-Identifier: MIT

async function preloadTemplates() {
	const templatePaths = [
		"modules/polyglot/templates/partials/settings.hbs",
		"modules/polyglot/templates/FontSettings.hbs",
		"modules/polyglot/templates/GeneralSettings.hbs",
		"modules/polyglot/templates/LanguageSettings.hbs",
	];

	return loadTemplates(templatePaths);
}

class PolyglotTour extends Tour {
	async _preStep() {
		await super._preStep();

		if (this.currentStep.actions) await this.performActions(this.currentStep.actions);

		// If there's tab info, switch to that tab
		if (this.currentStep.tab) await this.switchTab(this.currentStep.tab);
	}

	async performActions(actions) {
		for (const action of actions) {
			switch (action) {
				case "chat-message": {
					await ChatMessage.create({ content: "Polyglot Test Message", flags: { polyglot: { language: "test" } } });
					break;
				}
				case "user-config": {
					await game.user.sheet._render(true);
					break;
				}
				case "end": {
					this.configurator?.close();
					game.user.sheet.close();
					break;
				}
			}
		}
	}

	async switchTab(tab) {
		switch (tab.parent) {
			case "sidebar":
				ui.sidebar.activateTab(tab.id);
				break;
			case "settings": {
				const app = game.settings.sheet;
				await app._render(true);
				app.activateTab(tab.id);
				break;
			}
			case "general": {
				if (!this.configurator) {
					const configurator = game.settings.menus.get("polyglot.GeneralSettings");
					this.configurator = new configurator.type();
				}
				await this.configurator._render(true);
				this.configurator.activateTab(tab.id);
				break;
			}
		}
	}
}

function registerTours() {
	game.tours.register("polyglot", "test", new PolyglotTour(
		{
			title: "POLYGLOT.TOURS.Main.title",
			description: "POLYGLOT.TOURS.Main.desc",
			restricted: true,
			display: true,
			canBeResumed: true,
			steps: [
				{
					id: "canvas",
					title: "POLYGLOT.TOURS.Main.Canvas.Title",
					content: "POLYGLOT.TOURS.Main.Canvas.Content",
					tab: { parent: "sidebar", id: "chat" }
				},
				{
					id: "language-selector",
					selector: ".polyglot-lang-select",
					title: "POLYGLOT.TOURS.Main.LanguageSelector.Title",
					content: "POLYGLOT.TOURS.Main.LanguageSelector.Content"
				},
				{
					id: "language-selector-checkbox",
					selector: ".polyglot-lang-select input[name=\"polyglot-checkbox\"]",
					title: "POLYGLOT.TOURS.Main.LanguageSelectorCheckbox.Title",
					content: "POLYGLOT.TOURS.Main.LanguageSelectorCheckbox.Content"
				},
				{
					id: "language-selector-dropdown",
					selector: ".polyglot-lang-select span.select2-container",
					title: "POLYGLOT.TOURS.Main.LanguageSelectorSelect.Title",
					content: "POLYGLOT.TOURS.Main.LanguageSelectorSelect.Content"
				},
				{
					id: "language-selector-pips",
					selector: ".polyglot-lang-select span.select2-container",
					title: "POLYGLOT.TOURS.Main.LanguageSelectorPips.Title",
					content: "POLYGLOT.TOURS.Main.LanguageSelectorPips.Content",
					actions: ["chat-message"]
				},
				{
					id: "chat-message",
					selector: "#chat-log .chat-message:last-of-type",
					title: "POLYGLOT.TOURS.Main.ChatMessage.Title",
					content: "POLYGLOT.TOURS.Main.ChatMessage.Content",
				},
				{
					id: "chat-message-scrambled",
					selector: "#chat-log .chat-message:last-of-type .polyglot-original-text",
					title: "POLYGLOT.TOURS.Main.ChatMessageScrambled.Title",
					content: "POLYGLOT.TOURS.Main.ChatMessageScrambled.Content",
				},
				{
					id: "chat-message-translation",
					selector: "#chat-log .chat-message:last-of-type .polyglot-translation-text",
					title: "POLYGLOT.TOURS.Main.ChatMessageTranslation.Title",
					content: "POLYGLOT.TOURS.Main.ChatMessageTranslation.Content",
				},
				{
					id: "chat-message-globe",
					selector: "#chat-log .chat-message:last-of-type .polyglot-message-language",
					title: "POLYGLOT.TOURS.Main.ChatMessageGlobe.Title",
					content: "POLYGLOT.TOURS.Main.ChatMessageGlobe.Content",
				},
				{
					id: "chat-message-ending",
					selector: "#chat-log .chat-message:last-of-type",
					title: "POLYGLOT.TOURS.Main.ChatMessageEnding.Title",
					content: "POLYGLOT.TOURS.Main.ChatMessageEnding.Content",
				},
				{
					id: "players-list",
					selector: "#ui-left aside#players",
					title: "POLYGLOT.TOURS.Main.PlayersList.Title",
					content: "POLYGLOT.TOURS.Main.PlayersList.Content"
				},
				{
					id: "user-config",
					selector: ".window-app.user-config",
					title: "POLYGLOT.TOURS.Main.UserConfig.Title",
					content: "POLYGLOT.TOURS.Main.UserConfig.Content",
					actions: ["user-config"]
				},
				{
					id: "user-config-select-character",
					selector: ".window-app.user-config .form-group:has(ul#characters)",
					title: "POLYGLOT.TOURS.Main.UserConfigSelectCharacter.Title",
					content: "POLYGLOT.TOURS.Main.UserConfigSelectCharacter.Content"
				},
				{
					id: "actor-ownership",
					selector: "#sidebar #actors",
					title: "POLYGLOT.TOURS.Main.ActorOwnership.Title",
					content: "POLYGLOT.TOURS.Main.ActorOwnership.Content",
					tab: { parent: "sidebar", id: "actors" }
				},
				{
					id: "end",
					title: "POLYGLOT.TOURS.Main.End.Title",
					content: "POLYGLOT.TOURS.Main.End.Content",
					actions: ["end"]
				}
			]
		}
	));
}

Hooks.once("init", () => {
	CONFIG.TinyMCE.content_css.push("/modules/polyglot/styles/polyglot.css");
	registerSettings();
	const api = new PolyglotAPI();
	api.init();
	game.polyglot = new Polyglot();
	game.polyglot.init();
	api.attach();
	Hooks.callAll("polyglot.init", LanguageProvider);
	api.defaultProvider();
	api.updateProvider();
	game.polyglot.languageProvider.init();
	return preloadTemplates();
});

Hooks.once("i18nInit", () => {
	game.polyglot.languageProvider.i18nInit();
});

Hooks.on("setup", async () => {
	if (game.user.isGM && game.user.character) {
		console.warn(
			`Polyglot | ${game.i18n.format("POLYGLOT.GameMasterHasAssignedCharacter", {
				GM: game.i18n.localize("USER.RoleGamemaster"),
			})}`,
		);
	}
	registerProviderSettings();
	registerTours();
	await game.polyglot.languageProvider.setup();
});
Hooks.on("ready", () => {
	game.polyglot.ready();
	Hooks.callAll("polyglot.ready", LanguageProvider);
	game.polyglot.languageProvider.ready();
});
Hooks.on("renderSettingsConfig", renderSettingsConfigHandler);
Hooks.on("renderPolyglotGeneralSettings", renderPolyglotGeneralSettingsHandler);
//# sourceMappingURL=polyglot.js.map
